# Chapter8 애그리거트 트랜잭션 관리
## 8.1 애그리거트와 트랜잭션

한 주문 애그리거트에 대해, 운영자는 배송 상태를 변경하고 사용자는 배송지 주소를 변경하면 어떻게 될까?

<img width="400" alt="스크린샷 2024-05-28 오후 3 28 25" src="https://github.com/hoa0217/study-repo/assets/48192141/a50d67ef-1eb5-483d-a5c8-b7cf0fc91372">

- 트랜잭션마다 레포지토리는 새로운 애그리거트 객체를 생성하므로, 운영자 스레드와 고객 스레드는 다른 주문 애그리거트 객체를 구하게 된다.
  - 개념적으로는 동일하지만 물리적으로는 다른 애그리거트 객체를 사용한다.
- 따라서 운영자 스레드가 주문 애그리거트 객체를 배송상태로 변경하더라도, 고객 스레드 객체에는 영향을 주지 않는다.
  - 고객 입장에서는 아직 배송 전이므로 배송지 정보를 변경할 수 있다.
- 이 상황에 두 스레드는 각각 트랜잭션 커밋 시 수정한 내용을 DB에 반영한다.
  - 즉, 배송상태도 바뀌고 배송지 정보도 바뀐다.
- 애그리거트의 일관성이 깨진다.

일관성이 깨지지 않으려면 아래 중 하나를 선택해야한다.
- 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하게 막는다.
- 운영자가 배송지 정보를 조회한 이후 고객이 정보를 변경하면, 운영자 애그리거트를 다시 조회한 뒤 수정하도록 한다.

DBMS가 지원하는 트랜잭션과 함께, 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요하다.
- 선점(Pessimistic) 잠금 = 비관적 잠금
- 비전섬(Optimistic) 잠금 = 낙관적 잠금

## 8.2 선점 잠금

선점(Pessimistic) 잠금: 먼저 애그리거트를 구한 스레드가 사용을 끝낼 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.

<img width="400" alt="스크린샷 2024-05-28 오후 3 39 50" src="https://github.com/hoa0217/study-repo/assets/48192141/6a33c81c-70f0-4cba-a801-79cef07508c0">

1. 스레드1이 선점 잠금 방식으로 애그리거트를 구한 뒤 스레드2가 같은 애그리거트를 구한다.
2. 스레드1이 잠금을 해제할 때까지 스레드2는 블로킹(Blocking)된다.
3. 스레드1이 애그리거트를 수정하고 트랜잭션을 커밋하면 잠금을 해제한다.
4. 순간 대기하고 있던 스레드2가 애그리거트에 접근한다.

> 위 과정을 통해 스레드2는 스레드1이 수정한 애그리거트의 내용을 본다.

즉, 한 애그리거트가 수정하는동안 다른 스레드가 수정할 수 없으므로 데이터 충돌 문제를 해소할 수 있다.

선점 잠금은 보통 DBMS가 제공하는 행단위 잠금을 사용해서 구현한다.
- 다수의 DBMS가 for update와 같은 쿼리를 사용하여 특정 레코드에 한 커넥션만 접근할 수 있는 잠금장치를 제공한다.

#### JPA의 선점 잠금 기능
JPA EntityManager는 LockModeType을 인자로 받는 find메서드를 제공한다.
- LockModeType.PESSIMISTIC_WRITE를 전달하면 해당 엔티티와 매핑된 테이블을 이용해서 선점잠금방식을 적용할 수 있따.

<img width="500" alt="스크린샷 2024-05-28 오후 3 45 29" src="https://github.com/hoa0217/study-repo/assets/48192141/efa2218c-1b13-4be8-b7c3-fcb6bc5ec987">

JPA 프로바이더와 DBMS에 따라 잠금 모두 구현이 다르다.
- 하이버네이트의 경우 PESSIMISTIC_WRITE를 잠금모드로 사용하면, for update 쿼리를 이용해 선점 잠금을 구현한다.

<img width="500" alt="스크린샷 2024-05-28 오후 3 46 52" src="https://github.com/hoa0217/study-repo/assets/48192141/89cfb00b-a796-4f75-b4c8-5a86657895be">

> 스프링 데이터JPA는 @Lock 애너테이션을 사용해서 잠금 모드를 지정한다.

### 8.2.1 선점잠금과 교착 상태

선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태(dead lock)이 발생하지 않도록 주의해야한다.

#### 예시
1. 스레드1: A 애그리거트에 대한 선점 잠금 구함
2. 스레드2: B 애그리거트에 대한 선점 잠금 구함
3. 스레드1: B 애그리거트에 대한 선점 잠금 시도
4. 스레드2: A 애그리거트에 대한 선점 잠금 시도

이 순서에 따르면 스레드1도 스레드2도 영원히 애그리거트에 대한 선점 잠금을 구할 수 없다.
- 두스레드는 상대방 스레드가 먼저 선점한 잠금을 구할 수 없어 더 이상 다음 단계를 진행하지 못하고 교착 상태에 빠진다.

선점 잠금에 따른 교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자수가 많아지면 고착 상태에 빠지는 스레드는 빠르게 증가한다.

이런문제가 발생하지 않으려면, 잠금을 구할 때 최대 대기 시간을 지정해야한다.

#### JPA의 최대 대기 시간 지정
JPA에서 최대 대기 시간을 지정하려면 아래와 같이 **힌트**를 사용한다.
<img width="500" alt="스크린샷 2024-05-28 오후 3 52 51" src="https://github.com/hoa0217/study-repo/assets/48192141/1ad32df9-d702-4dac-a6ff-65d761d8363d">

- JPA의 `javax.persistence.lock.timeout` 힌트는 잠금을 구하는 대기 시간을 밀리초 단위로 지정한다.
- 지정한 시간 이내 잠금을 구하지 못하면 익셉션을 발생시킨다.
- 주의할 점은 DBMS에 따라 힌트가 적용되지 않을 수 있으니 DBMS가 관련 기능을 지원하는지 확인해야한다.

스프링 데이터 JPA는 @QueryHints 애너테이션을 사용하여 힌트를 지정한다.

<img width="500" alt="스크린샷 2024-05-28 오후 3 55 09" src="https://github.com/hoa0217/study-repo/assets/48192141/5043c207-5ba0-4d70-a9fd-b85043a8f04b">

> DBMS에 따라 교착 상태에 빠진 커넥션을 처리하는 방식이 다르므로 어떤 식으로 대기 시간을 처리하는지 반드시 확인해야한다. (DBMS에 따라 쿼리별로 또는 커넥션 단위로 대기 시간을 지정한다.)

## 8.3 비선점 잠금

선점 잠금이 강력해보이지만, 선점 잠금으로 모든 트랜잭션 충돌 문제가 해결되는 것은 아니다.

<img width="400" alt="스크린샷 2024-05-28 오후 3 59 11" src="https://github.com/hoa0217/study-repo/assets/48192141/fb1f8731-4785-45b6-afda-dee65a988160">

1. 운영자는 배송을 위해 주문 정보를 조회한다. 시스템은 정보를 제공한다.
2. 고객이 배송지 변경을 위해 변경 폼을 요청한다. 시스템은 변경 폼을 제공한다.
3. 고객이 새로운 배송지를 입력하고 폼을 전송하여 배송지를 변경한다.
4. 운영자가 1번에서 조회한 주문 정보를 기준으로 배송지를 정하고 배송 상태 변경을 요청한다.

즉, 배송상태 변경 전 배송지를 한 번 더 확인하지 않으면 운영자는 다른 배송지로 물건을 발송하게 되고 고객은 배송지를 변경했음에도 엉뚱한 곳으로 주문한 물건을 받는다. 이 문제는 선점 잠금 방식으로 해결할 수 없다.

#### 비선점 잠금
비선점 잠금: 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식

비선점 잠금을 구하려면 애그리거트 버전으로 사용할 숫자 타입 프로퍼티를 추가해야한다.

<img width="500" alt="스크린샷 2024-05-28 오후 4 03 51" src="https://github.com/hoa0217/study-repo/assets/48192141/f6abc18d-8e50-4e39-8245-0bcb2017984c">

- 이 쿼리는 수정할 애그리거트와 매핑되는 테이블 버전 값이 현재 애그리거트의 버전과 동일한 경우에만 데이터를 수정한다.
- 그리고 수정에 성공하면 버전값을 1증가 시킨다.
- 다른 트랜잭션이 먼저 데이터를 수정해 버전값이 바뀌면 데이터 수정은 실패한다.

<img width="500" alt="스크린샷 2024-05-28 오후 4 05 03" src="https://github.com/hoa0217/study-repo/assets/48192141/cb61e11f-4437-4e83-a3ee-c20769846706">

스레드1과 스레드2는 같은 버전을 갖는 애그리거트를 읽어와서 수정 후 스레드1이 먼저 커밋을 시도한다.
- 이때 버전은 여전히 5이므로 수정에 성공하고 버전은 6이된다.
- 하지만 그 후 스레드2가 커밋을 시도하면 버전이 맞지 않으므로 스레드2의 수정은 실패한다.

#### JPA의 비선점 잠금 기능
- JPA는 버전을 이용해서 비선점 잠금 기능을 지원한다.
- 아래와 같이 사용할 필드에 @Version애너테이션을 붙이고 매핑되는 테이블에 버전을 저장할 칼럼을 추가하면된다.

<img width="500" alt="스크린샷 2024-05-28 오후 4 07 36" src="https://github.com/hoa0217/study-repo/assets/48192141/b66c687b-0f13-4b8e-aa94-a4665614c092">

- JPA는 엔티티가 변경되어 UPDATE가 실행될 때 Version에 명시한 필드를 이용해서 비선점 잠금 쿼리를 실행한다.

<img width="500" alt="스크린샷 2024-05-28 오후 4 09 22" src="https://github.com/hoa0217/study-repo/assets/48192141/ecf4138a-c929-4241-98ab-93f1d97ef269">

#### 응용 서비스와 표현영역
응용 서비스는 버전에 대해서 알필요가 없다. 리포지터리에서 필요한 애그리거트를 구하고 알맞은 기능만 실행하면된다.
- 실행과정에서 애그리거트 데이터가 변경되면, JPA는 트랜잭션 종료 시점에 비선점 잠금을 위한 쿼리를 실행한다.

<img width="500" alt="스크린샷 2024-05-28 오후 4 11 29" src="https://github.com/hoa0217/study-repo/assets/48192141/27d48f97-5031-4428-8171-479b5743f6b6">

비선점 잠금을 위한 쿼리 실행 시, 수정된 행 개수가 0이라면 이는 트랜잭션이 충돌한 것이므로 트랜잭션 종료 시점 익셉션이 발생한다.
- 위 코드에서는 changeShipping메서드 리턴 시 트랜잭션이 종료되고 충돌이 발생하면 OptimisticLockingFailureException이 발생한다.
- 표현 영역에서는 이 예외가 발생했는지에 따라 트랜잭션 충돌을 확인할 수 있다.

<img width="500" alt="스크린샷 2024-05-28 오후 4 17 13" src="https://github.com/hoa0217/study-repo/assets/48192141/7e660ea3-4865-4c56-a25c-b56adc656e0a">

#### 비선점 잠금을 이용한 예시

<img width="500" alt="스크린샷 2024-05-28 오후 4 18 27" src="https://github.com/hoa0217/study-repo/assets/48192141/8b035a59-019f-421f-82b0-259548809f5d">

- 과정 2에서 운영자는 배송상태 변경 요청 시, 과정 1에서 받은 애그리거트 버전 값을 함께 전송한다.
- 만약 과정 1에서 받은 버전과 과정 2.1에서 읽은 버전이 다르면, 중간에 다른 사용자가 해당 애그리거트를 수정한 것이므로 에러를 응답한다.
- 만약 버전이 같다면 과정 1~2사이에 애그리거트를 수정하지 않은 것이므로, 2.1.3에서 애그리거트를 수정하고 2.1.4를 이용해 변경 내용을 DBMS에 반영한다.
- 그리고 2.1.1~2.1.4 사이에 아무도 애그리거트를 수정하지 않았다면 커밋에 성공하므로 성공 결과를 응답한다.
- 만약 2.1.1~2.1.4 사이에 누군가 애그리거트를 수정해서 커밋했다면 버전값이 증가한 상태가 되므로 커밋에 실패하고 결과로 에러를 응답한다.

<img width="500" alt="스크린샷 2024-05-28 오후 4 46 52" src="https://github.com/hoa0217/study-repo/assets/48192141/b86cb5c6-75d3-4c8c-88ba-5f6d63e7dc2d">

- `order.matchVersion()` 메서드는 현재 애그리거트 버전과 인자로 전달받은 버전이 일치하면 true를 리턴하고 그렇지 않으면 false를 리턴한다.
- `matchVersion()`의 결과가 true가 아니면 버전이 일치하지 않는 것이므로 응용 서비스는 예외를 던져 표현계층에 알린다.

<img width="500" alt="스크린샷 2024-05-28 오후 4 48 51" src="https://github.com/hoa0217/study-repo/assets/48192141/652463ca-d8e9-4354-a265-3ef6c74b6abb">

위 코드는 비선점 잠금과 관련해서 발생하는 두 개의 익셉션을 처리하고있다.
- OptimisticLockingFailureException: 스프링 프레임워크가 발생시키는 예외, 누군가 거의 동시에 애그리거트를 수정했다는 의미
- VersionConflictException: 응용 서비스에서 발생시키는 예외, 이미 누군가 애그리거트를 수정했다는 의미

> 버전 충돌 상황에 대한 구분이 명시적으로 필요없다면, 응용서비스에서 OptimisticLockingFailureException을 던지는 것을 고려할 수 도 있다.

### 8.3.1 강제 버전 증가

애그리거트에 애그리거트 루트 외에 다른 엔티티가 존재하는데, 기능 실행 도중 루트가 아닌 다른 엔티티의 값만 변경된다면?
- 이 경우 루트 엔티티 자체의 값이 바뀌는 것은 없으므로 버전 값을 증가 시키지 않는다.

이런 JPA특징은 애그리거트 관점에서 보면 문제가 된다. 애그리거트 구성요소 중 일부 값이 바뀌면 논리적으로 그 애그리거트는 바뀐 것이다.
- 따라서 어떤 구성요소의 상태가 바뀌면 루트 애그리거트 버전 값이 증가해야 비선점 잠금이 올바르게 동작한다.

#### JPA 해결법
`EntityManager.find()`메서드는 엔티티를 구할 때 강제로 버전 값을 증가시키는 잠금 모드를 지원한다.

<img width="500" alt="스크린샷 2024-05-28 오후 4 55 32" src="https://github.com/hoa0217/study-repo/assets/48192141/83ccd71a-3ebf-4952-b69f-89051d50b840">

LockModeType.OPTIMISTIC_FORCE_INCREMENT를 사용하면, 해당 엔티티의 상태가 변경되었는지에 상관없이 트랜잭션 종료 시점에 버전 값을 증가 처리한다.
- 이 잠금 모드를 사용하면, 루트엔티티가 아닌 다른 엔티티/밸류가 변경되더라도 버전값을 증가시킬 수 있으므로 비선점 잠금 기능을 안전하게 적용할 수 있다.

스프링 데이터 JPA를 사용하면 @Lock 애너테이션을 이용해서 지정하면 된다.

## 8.4 오프라인 선점 잠금

#### 컨플루언스
- 컨플루언스(Confluence)는 문서 편집 시 누군가 편집중이면 다른 사용자가 수정하고 있따는 안내문구를 보여준다.
- 그렇다고 동시에 수정하는것을 막지는 않지만 엄격하게 데이터 충돌을 막으려면 누군가 수정화면을 보고 있을 때 수정화면 실행을 못하게 막아야한다.
- 한 트랜잭션 범위에서만 적용되는 선점/비선점 잠금 방식으로는 이를 구현할 수 없다.
- 이 때 필요한 것이 오프라인 선점 잠금 방식(Offline Pessimistic Lock)이다.

#### 오프라인 선점 잠금
- 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다.
- 첫 번째 트랜잭션 시작 시 오프라인 잠금을 선점하고 마지막 트랜잭션에서 잠금을 해제한다.
- 잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다.

보통 수정기능은 두개의 트랜잭션으로 구성된다.
- 첫번째 트랜잭션은 폼을 보여주고, 두번째 트랜잭션은 데이터를 수정한다.

<img width="500" alt="스크린샷 2024-05-28 오후 5 06 14" src="https://github.com/hoa0217/study-repo/assets/48192141/5d2800ab-50f1-42bd-b4eb-ba8fcf2b265b">

- 과정1: 폼 요청과정에서 잠금을 선점한다.
- 과정3: 수정 과정에서 잠금을 해제한다.
- 과정2: 잠금이 선점되어있는 상태에서 폼을 요청하면 잠금을 구할 수 없으므로 에러화면을 마주한다.

여기서 만약 사용자 A가 과정3 수정 요청을 수행하지 않고 프로그램을 종료하며 어떻게 될까?
- 이 경우 잠금을 해제하지 않으므로 다른 사용자는 영원히 잠금을 구할 수 없다.
- 이런 사태를 방지하기 위해 오프라인 선점 방식은 **잠금 유효 시간**을 가져야 한다.
- 유효시간이 지나면 자동으로 잠금을 해제하여 다른 사용자가 잠금을 일정 시간 후 다시 구할 수 있도록 한다.

### 8.4.1 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스

오프라인 선점 잠금에는 4가지 기능이 필요하다.
- 잠금 선점 시도
- 잠금 확인
- 잠금 해제
- 잠금 유효시간 연장

이 기능을 위해 LockManager 인터페이스가 있다.

<img width="500" alt="스크린샷 2024-05-28 오후 5 11 59" src="https://github.com/hoa0217/study-repo/assets/48192141/cc7efdaa-7916-445c-9a5c-44fef88d7517">

`tryLock(String type, String id)`
- 잠글 대상 타입과 식별자를 값으로 전달한다.
- 잠금을 식별할 때 사용할 `LockId`를 리턴한다.

`LockId`는 잠금 구하기/해제하기/유효성검사/유효시간늘리기 등에 활용된다.

<img width="500" alt="스크린샷 2024-05-28 오후 5 15 07" src="https://github.com/hoa0217/study-repo/assets/48192141/3303f691-0817-464c-8a86-714e29b301c6">

오프라인 선점 잠금이 필요한 코드는 `LockManager.tryLock()`을 이용해 잠금을 시도한다.
- 잠금에 성공하면 `LockId`를 리턴하고 이는 다음 잠금을 해제할 때 사용한다.
- 따라서 이는 어딘가에 보관해야한다.

#### 예제

<img width="500" alt="스크린샷 2024-05-28 오후 5 16 37" src="https://github.com/hoa0217/study-repo/assets/48192141/ef1c8576-d31c-4313-998d-c1f24a58a0a8">

<img width="500" alt="스크린샷 2024-05-28 오후 5 16 57" src="https://github.com/hoa0217/study-repo/assets/48192141/d6faf15f-1511-487e-9086-d605b1120a4c">

만약 잠금을 선점하는데 실패하면 LockException이 발생한다. (이때 다른 사용자가 수정 중이니 나중에 다시 시도하라는 안내 화면을 보여주면 된다)

잠금을 해제하는 코드는 전달받은 LockId를 이용한다.

<img width="500" alt="스크린샷 2024-05-28 오후 5 19 07" src="https://github.com/hoa0217/study-repo/assets/48192141/af49f1f7-9249-4798-8f12-2398dc5a3a79">

<img width="500" alt="스크린샷 2024-05-28 오후 5 19 19" src="https://github.com/hoa0217/study-repo/assets/48192141/57ea8ee3-00cf-44ac-a89f-1c7bd3472912">

서비스 코드에서 `checkLock`메서드를 먼저 실행하는데, 아래와 같은 상황을 고려하여 잠금 선점 후 반드시 LockId를 갖는 잠금이 유효한지 확인해야한다.
- 잠금 유효시간이 지났으면 이미 다른 사용자가 잠금을 선점한다.
- 잠금을 선점하지 않은 사용자가 기능을 실행했다면 기능 실행을 막아야 한다.

### 8.4.2 DB를 이용한 LockManager 구현

잠금 정보를 저장할 테이블과 인덱스를 생성한다. (MySQL용)

<img width="500" alt="스크린샷 2024-05-28 오후 5 22 47" src="https://github.com/hoa0217/study-repo/assets/48192141/cc921118-3460-4e45-b581-2da3adb3519b">

만약 Order 타입의 1번 식별자를 갖는 애그리거트에 대한 잠금을 구하고 싶다면, 아래 insert쿼리를 이용해 locks 테이블에 데이터를 삽입하면된다.

```sql
insert into locks values('Order', '1', '생성한lockid', '2024-01-01 09:10:00');
```

> type과 id컬럼을 Primary키로 지정하여 동시에 두 사용자가 특정 데이터에 대한 잠금을 구하는 것을 방지했다.

locks테이블의 데이터를 담을 LockData 클래스를 아래와 같이 작성한다.

<img width="500" alt="스크린샷 2024-05-28 오후 5 25 58" src="https://github.com/hoa0217/study-repo/assets/48192141/3118a084-5654-4da4-8552-296f556372b7">

<img width="500" alt="스크린샷 2024-05-28 오후 5 26 21" src="https://github.com/hoa0217/study-repo/assets/48192141/019cb5d0-93b7-4d9e-80e6-3ceb7aa38eaa">

- `isExpired()`: 유효시간이 지났는지 판단할 때 사용

LockManager 구현 클래스는 생략.



