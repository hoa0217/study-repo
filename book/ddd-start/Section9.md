# Chapter9 도메인 모델과 바운디드 컨텍스트
## 9.1 도메인 모델과 경계

처음 도메인 모델을 만들 때 빠지기 쉬운 함정은 도메인을 완벽히 표현하는 단일 모델을 만드는 시도를 하는 것이다.
- 하지만 한 도메인은 다시 여러 하위 도메인으로 구분되기 때문에, 한 개의 모델로 모두 표현하려고 시도하면 오히려 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.

상품이라는 모델을 생각했을 때 `카탈로그`에서 상품, `재고 관리`에서 상품, `주문`에서 상품, `배송`에서 상품은 이름만 같지 실제 의미하는 것이 다르다.
- `카탈로그`에서 상품: 상품이미지, 상품명, 상품가격, 옵션목록, 상세 설명 ➡️ **상품 정보 위주**
- `재고 관리`에서 상품: 실존하는 **개별 객체를 추적**하기위한 목적

> 즉, 카탈로그에서는 물리적으로 한 개인 상품이 재고 관리에서는 여러개 존재할 수 있다.

논리적으로 같은 존재처럼 보이지만, 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다.
- 회원 도메인에서는 회원이지만, 주문 도메인에서는 주문자, 배송 도메인에서는 보내는 사람이라고 부른다.

<img width="400" alt="스크린샷 2024-05-28 오후 5 40 18" src="https://github.com/hoa0217/study-repo/assets/48192141/c2cea697-e344-41d2-b3af-65730770e849">

이렇게 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기에, 한 개의 모델로 모든 하위도메인을 표현하려는 시도는 올바른 방법이 아니다.

따라서 올바른 도메인 모델을 개발하려면, 하위 도메인마다 모델을 만들어야한다.
- 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야한다.
- 여러 하위 도메인의 모델이 섞이기 시작하면 모델의 의미가 약해질 뿐 아니라 여러 도메인의 모델이 서로 얽히기 때문에
- 하위 도메인별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워진다.

모델은 특정한 컨텍스트(문맥)하에 완전한 의미를 갖는다.
- 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 바운디드 컨텍스트(Bounded Context)라고 부른다.

## 9.2 바운디드 컨텍스트
바운디드 컨텍스트: 모델의 경계를 결정하며, 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.

이는 용어를 기준으로 구분한다.
- 카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 컨텍스트를 분리할 수 있다.
- 또한 실제로 사용자에게 기능을 제공하는 물리적 시스템으로 도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현한다.

이상적으로 하위 도메인과 바운디드 컨텍스트가 일대일관계를 가지면 좋겠지만, 팀의 조직 구조에 따라 결정되기도 한다.
- 예시로 주문 하위도메인이라도 주문을 처리하는 팀과 복잡한 결제 금액 계산 로직을 구현하는 팀이 따로 있다면?
- 이 경우 주문 하위도메인에 주문 바운디드 컨텍스트와 결제 금액 계산 바운디드 컨텍스트가 존재하게 된다.
- 그리고 카탈로그와 재고관리가 명확하게 구분되지 않은 경우 두 하위 도메인을 하나의 바운디드 컨텍스트에서 구현하기도한다.

<img width="500" alt="스크린샷 2024-05-28 오후 5 47 24" src="https://github.com/hoa0217/study-repo/assets/48192141/1d0a5ea0-d3b4-4d00-9392-c01b1ac13805">

규모가 작은 기업은 전체 시스템을 한 개 팀에서 구현할 때도 있다.
- 소규모 쇼핑몰은 한 어플리케이션에서 서비스를 하기에 한 시스템에서 회원, 카탈로그, 재고, 구매, 결제와 관련된 모든 기능을 제공한다.
- 즉, 여러 하위 도메인을 한개의 바운디드 컨텍스트에서 구현한다.

이 경우 주의할 점은 **하위 도메인의 모델이 섞이지 않도록 해야한다.**
- 한 프로젝트에 각 하위 도메인의 모델이 위치하면, 전체 하위 도메인을 위한 단일 모델을 만들고 싶은 유혹에 빠지기 쉽다.
- 이런 유혹에 걸려들면 결과적으로 도메인 모델이 개별 하위 도메인을 제대로 반영하지 못하여 하위 도메인 별 기능을 확장하기 어렵게 된다.

비록 한개의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 갖도록 구현해야한다.
- 이렇게 함으로써 하위 도메인을 위한 모델이 서로 뒤섞이지 않고 하위 모데인마다 바운디드 컨텍스트를 갖는 효과를 낼 수 있다.

<img width="500" alt="스크린샷 2024-05-28 오후 5 53 56" src="https://github.com/hoa0217/study-repo/assets/48192141/ca4887ef-f306-450b-9f43-7636f83f99c2">

바운디드 컨텍스트는 구현하는 하위 모데인에 알맞는 모델을 포함한다.
- 같은 사용자여도 회원 바운디드 컨텍스트에서는 Memeber가 애그리거트 루트이지만, 주문 바운디드 컨텍스트에서는 Orderer가 밸류가 된다.
- 같은 상품이라도 카탈로그 바운디드 컨텍스트의 Product는 Category와 연관을 갖지만, 재고 바운디드 컨텍스트의 Product는 카탈로그의 Category와 연관을 맺지 않는다.

<img width="500" alt="스크린샷 2024-05-28 오후 5 58 40" src="https://github.com/hoa0217/study-repo/assets/48192141/eb2075e8-af7c-46a7-808a-4888bfe30c36">

## 9.3 바운디드 컨텍스트 구현

바운디드 컨텍스는 도메인 기능을 사용자에게 제공하는데 필요한 표현영역, 응용서비스, 인프라스트럭처 영역을 모두 포함한다.
- 도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야하므로 테이블도 포함된다.

<img width="400" alt="스크린샷 2024-05-28 오후 6 00 47" src="https://github.com/hoa0217/study-repo/assets/48192141/2b2c1922-b768-44f1-805c-1c020614d6ad">

> 표현 영역은 사용자를 위해 HTML 페이지를 생성할 수도 있고, 다른 바운디드 컨텍스트를 위해 REST API를 제공할 수 도 있다.

모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.
- 상품 리뷰는 복잡한 도메인 로직이 없기 때문에 CRUD 방식 구현해도 된다.
- DAO-데이터 중심의 밸류 객체를 이용해서 리뷰 기능을 구현해도 유지 보수에 문제가 없다.
- 물론 서비스-DAO 구조를 사용하면 도메인 기능이 서비스에 흩어지게되지만, 도메인 기능이 단순하면 유지 보수에 문제가 없다.
<img width="500" alt="스크린샷 2024-05-28 오후 6 03 49" src="https://github.com/hoa0217/study-repo/assets/48192141/7e2599d1-d6e7-4570-aa54-66ff90553fa0">

한 바운디드 컨텍스트에서 두 방식을 혼합해서 사용할 수 있다.
- 대표적인 예가 CQRS(Command Query Responsibility Segregation) 패턴이다.
- 이는 상태를 변경하는 명령 기능과 내용을 조회하는 쿼리 기능을 위한 모델을 구분하는 패턴이다.
- 이를 단일 바운디드 컨텍스트에 적용하면, 상태 변경과 관련된 기능은 도메인 모델 기반으로 구현하고 조회 기능은 서비스-DAO를 이용해서 구현할 수 있다.

<img width="500" alt="스크린샷 2024-05-28 오후 6 12 40" src="https://github.com/hoa0217/study-repo/assets/48192141/00fcf556-5337-400f-ba06-4e987d65b17f">

각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수 있다.
- 스프링MVC + JPA/하이버네티트를 사용하는 바운디드 컨텍스트가 존재할 수 있고, Netty + Mybatis를 사용하는 바운디드 컨텍스트가 존재할 수 있다.
- 어떤 바운디드 컨텍스트는 RDBMS 대신, 몽고DB같은 NoSQL을 사용할 수도 있다.

바운디드 컨텍스트는 반드시 사용자에게 보여지는 UI를 가지고 있어야 하는 것은 아니다.
- 카탈로그 바운디드 컨텍스트를 통해 상세정보를 읽어온뒤, 리뷰 바운디드 컨텍스트의 API호출 해 로딩한 JSON 데이터를 알맞게 가공하여 리뷰목록을 보여줄 수 있다.

<img width="500" alt="스크린샷 2024-05-28 오후 6 16 32" src="https://github.com/hoa0217/study-repo/assets/48192141/38f166d2-f7df-4759-acac-5ce931773c86">

또는 UI 서버를 두고, UI 서버에서 바운디드 컨텍스트와 통신해 사용사 요청을 처리하는 방법도 있다.
- 여기서 UI서버는 각 바둔디드 컨텍스트를 위한 퍼사드 역할을 수행한다.
- 브라우저가 UI서버에 요청을 보내면 UI서버는 카탈로그와 리뷰 바운디드 컨텍스트로부터 필요한 정보를 읽어와 조합한 뒤 브라우저데 응답을 제공한다.

<img width="500" alt="스크린샷 2024-05-28 오후 6 18 20" src="https://github.com/hoa0217/study-repo/assets/48192141/acf1ea6f-3e63-4c85-a594-da996be7fe3a">

## 9.4 바운디드 컨텍스트 간 통합

- 사용자가 카탈로그 바운디드 컨텍스트에 추천 제품 목록을 요청하면, 카탈로그 바운디드 컨텍스트 추천 바운디드 컨테스트로부터 추천 정보를 읽어와 추천 제품 목록을 제공한다.
- 이때 카탈로그 컨텍스트와 추천 컨텍스트의 도메인 모델이 서로 다르다. 카탈로그는 제품을 중심으로 도메인 모델을 구현하지만, 추천은 추천 연산을 위한 모델을 구현한다.
- 카탈로그 시스템은 추천 시스템으로부터 추천 데이터를 받아오지만, 카탈로그 시스템에서는 추천의 도메인 모델을 사용하기 보다 카탈로그 도메인 모델을 사용해서 추천 상품을 표현해야한다.

<img width="500" alt="스크린샷 2024-05-28 오후 10 12 25" src="https://github.com/hoa0217/study-repo/assets/48192141/0394cb42-1f57-4f20-b480-e3ecbb898fef">

- 도메인 서비스 구현 클래스는 인프라스트럭처에 위치하고, 이 클래스는 외부시스템과의 연동 처리 및 외부 시스템의 모델과 현재 도메인 모델 간의 변환을 책임진다.

<img width="500" alt="스크린샷 2024-05-28 오후 9 55 41" src="https://github.com/hoa0217/study-repo/assets/48192141/11d43e18-9428-4169-b886-8ce123fb5eaf">

- RecSystemClient는 외부 추천 시스템이 제공한느 Rest API를 이용해 특정 상품 목록을 로딩한다.
- 아래 코드는 RestAPI로부터 데이터를 읽어와 카탈로그 도메인으로 변환한다. (가상으로 만든것)

<img width="500" alt="스크린샷 2024-05-28 오후 10 15 41" src="https://github.com/hoa0217/study-repo/assets/48192141/1f398000-6a31-4006-aa5a-f4f0a194359e">

- getRecItems()메서드를 사용하는 externalRecClient는 외부 추천 시스템에 연결할 때 사용하는 클라이언트라고 가정하자.
- 이 모듈이 제공하는 RecommendationItem은 추천 시스템의 모델을 따른다.
- RecSystemClient는 추천 시스템 모델을 받아와 toProducts()메서드를 이용해서 카탈로그 도메인의 Product모델로 변환하는 작업을 처리한다.

> 두 모델간 변환과정이 복잡하면 별도 변환 클래스를 만들어도 된다.

<img width="500" alt="스크린샷 2024-05-28 오후 10 18 32" src="https://github.com/hoa0217/study-repo/assets/48192141/d5be9cef-ba47-416f-bee1-3d2d66ff80cb">

- Rest API 호출은 두 바운디드 컨텍스트를 직접 통합하는 방법이다.
- 직접 통합하는 대신 간접적으로 통합하는 방법으로는 메시지큐를 사용하는 것이다.
- 사용자가 조회/구매한 상품이력 등을 전달할 때 메시지 큐를 사용할 수 있다.

<img width="500" alt="스크린샷 2024-05-28 오후 10 19 33" src="https://github.com/hoa0217/study-repo/assets/48192141/cdba298c-fb0f-44c7-a173-e4218d00d932">

- 카탈로그 도메인은 메시징 큐에 카탈로그 관련 메시지를 저장하게되고, 다른 바운디드 컨텍스트는 이 큐로부터 필요한 메시지를 수신하는 방식을 사용한다.
- 즉, 한쪽에서 메시지를 출판하고 다른 쪽에서 미시지를 구독하는 출판/구독 모델을 따른다.

<img width="500" alt="스크린샷 2024-05-28 오후 10 24 22" src="https://github.com/hoa0217/study-repo/assets/48192141/2d9f83f8-c0a8-4109-9e33-4528aa27f04d">

- 큐를 추천 시스템에서 제공할 경우, 큐를 통해 메시지를 추천 시스템에 전달하는 방식이 된다.
- 즉, 큐를 가지고 비동기로 추천 시스템에 데이터를 전달하는 것을 제외하면 추천 시스템이 제공하는 Rest API를 사용해서 데이터를 전달하는 것과 차이가없다.

> 마이크로서비스/바운디드 컨텍스트   
> 마이크로서비스는 애플리케이션을 작은 서비스로 나누어 개발하는 아키텍처 스타일이다.   
> 개별 서비스를 독립된 프로세스로 실행하고, 각 서비스가 RestAPI/메시징을 이용해 통신한다.   
> 이런 마이크로서비슨느 바운디드 컨텍스트와 잘 어울린다. 각 바운디드 컨텍스트는 모델의 경계를 형성하는데 바운디드 컨텍스트를 마이크로서비스로 구현하면 자연스럽게 컨텍스트별 모델이 분리된다.   
> 별도 프로세스로 개발한 바운디드 컨텍스트를 독립적으로 배포/모니터링하며 확장되는데 이 역시 마이크로서비스가 갖는 특징이다.

## 9.5 바운디드 컨텍스트 간 관계

바운디드 컨텍스트는 다양한 방식으로 관계를 맺는다.

#### 상류컴포넌트 하류컴포넌트
가장 흔한관계는 한쪽에서 API를 제공하고 한쪽에서 API를 호출한다. ex) Reset API

<img width="500" alt="스크린샷 2024-05-28 오후 10 32 24" src="https://github.com/hoa0217/study-repo/assets/48192141/5403fa11-90f6-42e7-ad09-714a5b4e2191">

- 하류 컴포턴트인 카탈로그 컨텍스트는 상류 컴포넌트인 추천 컨텍스트가 제공하는 데이터와 기능에 의존한다.
- 카탈로그는 추천 상품을 보여주기 위해 추천 바운디드 컨텍스트가 제공하는 Rest API를 호출한다.
- 추천 시스템이 제공하는 Rest API의 인터페이스가 바뀌면 카탈로그 시스템의 코드도 바뀐다.
- 즉, 상류 컴포넌트는 서비스 공급자 역할, 하류 컴포넌트는 고객역할을 하며 이들은 개발 계획을 서로 공유하고 일정을 협의해야한다.

상류 컴포넌트는 보통 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의한다.
- 상류 팀의 고객인 하류 팀이 다수 존재하면 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고 이를 서비스 형태로 공개하여 서비스의 일관성을 유지할 수 있다. ➡️호스트 서비스(Open Host Service)

공개 호스트 서비스의 대표적 예가 **검색**이다.
- 블로그, 카페, 게시판 서비스를 제공하는 포털은 검색을 위한 전용 시스템을 구축하고 각 서비스를 통합한다.
- 상류팀(검색)은 각 하류 컴포넌트(블로그, 카페, 게시판)의 요구사항을 수용하는 단일 API를 만들어 공개하고 하류팀은 해당 API를 사용하여 검색 기능을 구현한다.

<img width="500" alt="스크린샷 2024-05-28 오후 10 37 31" src="https://github.com/hoa0217/study-repo/assets/48192141/7845103b-1903-4194-a4df-b68fe78b126f">

상류 컴포넌트의 서비스는 상류 바운디드 컨텍스트의 도메인 모델을 따른다.
- 따라서 하류 컴포넌트는 상류 서비스의 모델이 자신의 도메인 모델에 영향을 주지 않도록 보호해주는 **완충 지대**를 만들어야한다.

#### 안티코럽션 계층
<img width="500" alt="스크린샷 2024-05-28 오후 10 38 45" src="https://github.com/hoa0217/study-repo/assets/48192141/9b51f9c1-aa31-41b5-8828-d2cc91499c28">

RecSystemClient는 외부시스템과의 연동을 처리하는데, 외부 시스템의 도메인 모델이 내부 도메인 모델을 침범하지 않도록 막아주는 역할을 한다.
- 즉, 모델이 깨지는 것을 막아주는 안티코럽션 계층이 된다.
- 두 바운디드 컨텍스트 간 모델 변환을 처리해주기 때문에 다른 바운디드 컨텍스트의 모델에 영향을 받지 않고 내부 도메인 모델을 유지할 수 있다.

#### 공유커널
두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있다.
- 운영자를 위한 주문관리 도구를 개발하는 팀과 고객을 위한 주문 서비스를 개발하는 팀이 다를 때
- 두 팀은 주문을 표현하는 모델을 공유함으로써 주문과 관련된 중복 설계를 막을 수 있다
- 두 팀이 공유하는 모델을 공유 커널(Shared Kernel)이라고 부른다

공유 커널의 장점은 중복을 줄여준다는 것이다.
- 두 팀이 하나의 모델을 개발해서 공유하기 때문에, 두번 개발하는 중복을 줄일 수 있다.
- 하지만 두팀이 공융하기 때문에, 한팀에서 모델을 변경하면 안되며 두 팀이 밀접한 관계를 유지해야한다.
- 형성할 수 없다면 공유 커널을 사용할 때 장점보다 개발이 지연되는 정체 문제가 커진다.

#### 독립방식
독립방식: 서로 통합하지 않는 방식. 통합하지 않으므로 독립적인 모델을 발전시킨다.
- 독립 방식에서 두 바운디드 컨텍스트간의 통합은 수동으로 이루어진다.
- 온라인 쇼핑몰 솔루션과 외부 ERP서비스를 사용하고 있을 때, 이둘은 연동을 지원하지 않으므로 쇼핑몰 판매가 발생하면 쇼핑물 운영자는 판매정보를 ERP에 직접 입력해야한다.

<img width="500" alt="스크린샷 2024-05-28 오후 10 51 02" src="https://github.com/hoa0217/study-repo/assets/48192141/91994815-51f0-4239-a477-e92b16f4e7be">

- 수동 통합이 나쁜것은아니지만 한계가 있으므로 규모가 커지시 시작하면 두 바운디드 컨텍스트를 통합해야한다.
- 이때 외부 솔루션과 ERP를 완전히 대체할 수 없다면 두 바운디드 컨텍스트를 통합해주는 별도 시스템을 만들어야할 수 도 있다.

<img width="500" alt="스크린샷 2024-05-28 오후 10 52 14" src="https://github.com/hoa0217/study-repo/assets/48192141/98c8f0f1-d954-4678-8904-0257149bd5ef">

## 9.6 컨택스트 맵

개별 바운디드 컨텍스트에 매몰되면 전체를 보지 못할 때가 있다.
- 전체 비지니스를 조망할 수 있는 지도가 필요한데 그것이 컨텍스트맵이다.

<img width="500" alt="스크린샷 2024-05-28 오후 10 53 20" src="https://github.com/hoa0217/study-repo/assets/48192141/27ac8ba0-209a-4cfb-a1c5-c059a7b05189">

- 그림을 통해 바운디드 컨텍스트의 경계가 드러나고, 서로 어떤 관계를 맺고 있는지 알 수 있다.
- 바운디드 컨텍스트에 주요 애그리거트를 함께 푯하면 관계가 더 명확히 드러난다.
- 그림은 오픈 호스트 서비스(OHS)와 안티코럽션 계층(ACL)만 표현했는데, 하위 도메인이나 조직구조를 함께 표시하면 전체 관계를 이해하는데 도움된다.

컨텍스트 맵은 시스템의 전체 구조를 보여준다.
- 하위 도메인과 일치하지 않는 바운디드 컨텍스트를 찾아 도메인에 맞게 바운디드 컨텓스트를 조절하고 사업의 핵심 도메인을 위해 조직 역량을 어떤 바운디드 컨텍스트에 집중할 지 파악하는데 도움을 준다.

컨텍스트 맵 규칙은 따로없다.
- 간단한 도형과 선을 이용해서 각 컨텍스트의 관계를 이해할 수 있는 수준에서 그리면된다.
- 컨택스트 맵은 단순하기 때문에 화이트보드/파워포인트와 같은 도구를 이용해서 그릴 수 있다.


