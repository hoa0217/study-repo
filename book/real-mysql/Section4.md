# 아키텍처
- MySQL 엔진: 사람 머리
- 스토리지 엔진: 사람 손발 역할
  - InnoDB
  - MyISAM
> 핸들러 API를 누구든 스토리지 엔진을 구현하여 MySQL 서버에 추가하여 사용할 수 있음.

## 4.1 MySQL 엔진 아키텍처
### 4.1.1 MySQL의 전체 구조

<img src="https://github.com/hoa0217/study-repo/assets/48192141/7b07b4ed-1b86-4604-b858-6ac6c77a6c7e" width="600">

- MySQL은 대부분의 프로그래밍 언어로부터 접근 방법을 모두 지원한다.
  - C API, JDBC, ODBC, .NET 표준 드라이버 제공하여 C/C++, PHP, 자바, 펄, 파이썬, 루비 .NET 및 코볼까지 모든 언어로 MySQL 서버에서 쿼리를 사용할 수 있다.
- MySQL서버 = MySQL 엔진 + 스토리지 엔진 

#### 4.1.1.1 MySQL 엔진
- MySQL 엔진 = 커넥션 핸들러(클라이언트 접속) + SQL 파서 및 전처리기(쿼리 요청 처리) + 옵티마이저(쿼리 최적화)
- MySQL은 표준 SQL문법을 지원하기 때문에, 타 DBMS와 호환되어 실행될 수 있다.

#### 4.1.1.2 스토리지 엔진
- MySQL 엔진은 요청된 SQL 분석 및 최적화등 DBMS의 두뇌를 담당
- 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 담당
- MySQL 서버에서 엔진은 하나지만, 스토리지 엔진은 여러개를 동시에 사용 가능
```sql
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```
> 스토리지 엔진을 지정하면, 해당 테이블의 모든 작업은 정의된 스토리지 엔진이 처리한다.
- 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM)나 InnoDB 버퍼 풀(InnoDB)같은 기능을 내장하고 있다.

#### 4.1.1.3 핸들러 API
- MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 요청한다.
- 이를 **Handler 요청**이라 하며, 사용되는 API를 **Handler API**라고 한다.
- 스토리지 엔진 또한 이 Handler API를 사용하여 MySQL 엔진과 데이터를 주고 받는다.
```sql
SHOW GLOBAL STATUS LIKE 'Handler%'; // 얼마나 많은 데이터 작업이 있었는지 확인 가능
```
<img src="https://github.com/hoa0217/study-repo/assets/48192141/6f95225e-07be-4984-9dd6-efa4b9930510" width="400">

### 4.1.2 MySQL 스레딩 구조

<img src="https://github.com/hoa0217/study-repo/assets/48192141/af5282ff-ea7d-44fd-beb8-ba06ba7eeb78" width="600">

- MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 포그라운드(Foreground)스레드와 백그라운드(Background)스레드로 타입을 구분할 수 있다.

```sql
SELECT thread_id, name, type, processlist_user, processlist_host
FROM performance_schema.threads ORDER BY type, thread_id;
```

<img src="https://github.com/hoa0217/study-repo/assets/48192141/79b49b3f-9163-4088-89dc-146c28f44350" width="500">

...

<img src="https://github.com/hoa0217/study-repo/assets/48192141/a3045bbd-f674-446d-95f3-7feb4520d858" width="500">

- MySQL 서버에서 실행중인 스레드는 `performance_schema` 데이터베이스의 `threads` 테이블을 통해 확인할 수 있다.
- 백그라운드와 포그라운드 스레드가 type으로 표시되어 있으며, 그 중 마지막 `thread/sql/one_connection` 스레드만이 사용자의 요청을 처리하는 포그라운드 스레드이다.
- 백그라운드 스레드 개수는 MySQL 서버의 설정 내용에 따라 가변적일 수 있다.
- 동일한 이름의 스레드가 2개 이상씩 보이는 것도 MySQL 서버 설정에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우이다.

> 참고: 여기서 소개하는 스레드 모델은 커뮤니티 에디션에서 사용되는 전통적인 스레드 모델이다. 엔터프라이즈 에디션과 Percona MySQL서버에서는 스레드 풀(Thread Pool)모델도 사용할 수 있다.   
> 가장 큰 차이점은 **포그라운드 스레드와 커넥션**의 관계이다. 전통적인 스레드 모델은 커넥션별 포그라운드 스레드가 하나씩 생성되지만 스레드풀에서는 하나의 스레드가 여러 개의 커넥션 요청을 전담한다.

#### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)
- 포그라운드 스레드는 최소 MySQL 서버에 접속된 **클라이언트의 수**만큼 존재하며, 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.
- 커넥션을 종료하면 커넥션을 담당하던 스레드는 다시 **스레드 캐시**(Thread cache)로 되돌아간다.
- 이미 스레드 캐시에 일정 개수 이상의 대기중인 스레드가 있다면, 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 한다.
- 이때 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 `thread_cache_size` 시스템 변수로 설정한다.
- 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우 직접 디스크 또는 인덱스파일로부터 데이터를 읽어와서 처리한다.
- MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만, 
- InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.

> `사용자 스레드 == 포그라운드 스레드`   
> MySQL 서버에 접속하게 되면 클라이언트 요청을 처리해줄 스레드를 생성해 클라이언트에게 할당한다.
> 이 스레드는 앞단에서 클라이언트와 통신하기 때문에 포그라운드 스레드라고 하며, 사용자가 요청한작업을 처리하기 때문에 사용자 스레드라고도 한다.

#### 4.1.2.2 백그라운드 스레드
MyISAM의 경우 해당 사항이 없지만, InnoDB는 아래와 같은 작업이 백그라운드로 처리된다.
- 인서트 버퍼(Insert Buffer)를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

가장 중요한것은 쓰기 쓰레드(Write thread)이다.
- 쓰기 쓰레드는 로그 스레드(Log thread)와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리함.
- MySQL5.5 버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있게 됐으며, 
- `innodb_write_io_threads`, `innodb_read_io_threads` 시스템 변수로 설정할 수 있다.
- InnoDB에서도 읽는건 주로 클라이언트 스레드에서 처리되기때문에 읽기 쓰레드를 많이 설정할 필요가 없지만
- 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에, 디스크는 2~4 스토리지(DAS, SAN)는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.

사용자의 요청을 처리하는 도중 쓰기 작업은 지연(버퍼링)되어도 처리될 수 있지만, 데이터의 읽기 작업은 절대 지연될 수 없다.
- 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있다 = InnoDB
- 하지만 MyISAM은 사용자 쓰레드가 쓰기 작업까지 함께 처리하도록 설계되어 있다.
- 이러한 이유로 InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크로 완전히 저장될 때까지 기다리지 않아도 된다.
- 하지만 MyISAM에서 일반적인 쿼리는 쓰기 버퍼링을 사용할 수 없다.

### 4.1.3 메모리 할당 및 사용 구조

<img width="600" alt="스크린샷 2024-04-16 오후 11 28 22" src="https://github.com/hoa0217/study-repo/assets/48192141/95e07909-9188-4db3-bb00-69afe5b22be0">

- 글로벌 메모리 영역 : 모든 메모리 공간은 MySQL 서버가 시작되면서 시스템 변수로 설정해 둔 만큼 OS로부터 할당된다.
- 로컬 메모리 영역

#### 4.1.3.1 글로벌 메모리 영역
일반적으로 하나의 메모리 공간만 할당된다. 필요에 의해 2개 이상을 받을 수 도 있지만 클라이언트 스레드 수와 무관하다. N개라 하더라도 모든 스레드에 의해 공유된다.

[대표적인 글로벌 메모리영역]
- 테이블 캐시
- InnoDB 버퍼풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

#### 4.1.3.2 로컬 메모리 영역
세션 메모리 영역이라고도 표현하며, 클라이언트 스레드가 쿼리를 처리하는데 사용되는 메모리 영역이다. = `클라이언트 메모리 영역`
- 클라이언트가 MySQL 서버에 접속하면 클라이언트 커넥션으로부터 요청을 처리하기 위해 스레드를 하나씩 할당하게 되며, 해당 스레드가 사용하는 메모리 공간이다.
- 서버와의 커넥션을 세션이라고 하기 때문에 로컬 메모리 영역을 `세션 메모리 영역`이라고도 표현한다.

로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되지 않는다.
- 글로벌 메모리영역의 크기는 주의해서 설정해야하지만, 로컬 메모리 영역은 크게 신경쓰지 않고 설정한다.
- 가능성은 희박하지만 서버가 메모리 부족으로 멈춰 버릴 수 도 있으므로 적절한 메모리 공간을 설정하는 것이 중요하다.

각 쿼리의 용도별로 필요할 때만 메모리 공간이 할당되고 필요하지 않은 경우 할당되지 않는다.
- 커넥션이 열려 있는 동안 계속 할당된 상태로 남아있는 공간도 있고 (커넥션 버퍼나 결과 버퍼)
- 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간도 있다. (소트 버퍼나 조인 버퍼)

[대표적인 로컬 메모리 영역]
- 정렬 버퍼(Sort Buffer)
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼