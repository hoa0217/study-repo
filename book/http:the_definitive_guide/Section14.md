### 14.1 HTTP안전하게 만들기

웹은 안전한 방식의 HTTP를 필요로 하며, 아래와 같은 보안 기술이 필요로한다.

- 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기 하고 있음을 알 수 있어야 한다.
- 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기 하고 있음을 알 수 있어야 한다.
- 무결성 - 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
- 암호화 - 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
- 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야한다.
- 편재성(Ubiquity) - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- 관리상 확장성 - 누그든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 한다.
- 사회적 생존성 - 사회의 문화적, 정치적 요구를 만족시켜야 한다.

#### 1.4.1 HTTPS
- HTTPS는 HTTP를 안전하게 만드는 방식 중 가장 인기 있는 것이다.
    - 넷스케이프 커뮤니케이션 주식회사에서 개척하여, 주류 브라우저와 서버에서 지원한다.
    - URL이 `https://`로 시작한다.
- HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전 암호화 된다.
- HTTPS는 HTTP 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작한다.
    - 이 보안 계층은 안전 소켓 계층(Secure Sockets Layer, SSL)혹은 그를 계승한 전송 계층 보안(Transport Layer Security, TLS)로 구현된다.
- SSL과 TLS는 매우 비슷하기 때문에 이 책에서는 양쪽 모두 **SSL**이라는 단어를 사용한다.
- HTTPS

    |프로토콜|계층|
    |------|---|
    |HTTP|응용 계층|
    |SSL 혹은 TLS|보안 계층|
    |TCP|전송 계층|
    |IP|네트워크 계층|
    |네트워크 인터페이스|데이터 링크 계층|

    > 인코딩/디코딩은 대부분 SSL 라이브러리 안에서 일어나기 때문에, HTTP를 사용하기 위해 클라이언트/서버가 프로토콜 처리 로직을 변경할 필요는 없다.
   
    > 대부분 TCP 입력/출력 호출을 SSL 호출로 대체하고, 보안 설정 및 관리를 위한 몇가지 호출을 추가하기만 하면된다.

### 14.2 디지털 암호학

- 암호 : 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키 : 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계 : 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계 : 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법 : 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명 : 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서 : 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

#### 14.2.1 비밀 코드의 기술과 과학
- 압호법(crtptography) : 메시지 인코딩과 디코딩에 대한 과학이자 기술이다.
- 암호법은 단순 메시지를 암호화하는 것 뿐 아니라, 변조를 방지하기 위해 사용할 수 있다.
- 암호법은 누군가를 어떤 메시지나 트랜잭션의 저자임을 증명하는데도 사용될 수 있다.

#### 14.2.2 암호(cipher)
- 암호법은 암호란 비밀 코드에 기반한다.
- **암호** : 메시지를 인코딩하는 어떤 특정한 방법과, 그 메시지를 디코딩하는 방법
- 평문 : 인코딩 되기 전의 원본
- 암호문 : 암호가 적용되어 코딩된 메시지
- 평문 ➡ 인코더 ➡ 암호문 ➡ 디코더 ➡ 평문

    <img src="img/14-3.jpeg" width="600"/>

- Rotate-by-3 암호 : 글자의 알파벳 순서상 세 번 뒤의 글자로 교체

    <img src="img/14-4.jpeg" width="600"/>

    - 인코딩 : 3글자 만큼 회전
    - 디코딩 : -3글자 만큼 회전
    
#### 14.2.3 암호 기계
- 암호는 상대적으로 간단한 알고리즘으로 시작했다.
    - 간단한 암호로 인해 사람들은 암호화 작업을 수기로 수행할 수 있었고 암호를 깨뜨리는 것도 가능했다.
- 기술이 진보하면서 복잡한 암호로 메시지를 빠르고 정확하게 인코딩, 디코딩하는 기계를 만들었다.
    - 단순 회전대신 글자를 대체하고 순서를 바꾸고 메시지를 토막냈다.

#### 14.2.4 키가 있는 암호
- 키 : 암호의 동작방식을 변경할 수 있는 숫자
- 디코딩 과정을 바르게 동작시키려면 올바른 키를 암호 기계에 임력해야한다.
- 암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어준다.
- 이 가상 암호 기계들은 서로 다른 키 값을 갖고 있기 때문에 제각각 다르게 동작한다.

    > 오늘날 대부분의 암호 알고리즘은 키를 사용한다.

#### 14.2.5 디지털 암호
- 디지털 계산의 도래로 디지털 암호가 발전했다.
    - 복잡한 인코딩, 디코딩 알고리즘이 가능해졌다.
    - 매우 큰 키를 지원하는 것이 가능해졌다.
    - 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 알고리즘을 만들어 낼 수 있다.
- 디지털 키는 물리적 금속 키나 다이얼 설정과 달리, 그냥 숫자에 불과하다.
    - 디지털 키 값은 인코딩/디코딩 알고리즘에 대한 입력값이다.
- 평문 메시지 P, 인코딩 함수 E, 인코딩 키 e가 주어지면 암호화문 C를 인코딩할 수 있다.
- 암호문 C를 디코더 함수 D와 디코딩 키 d를 사용해서 평문 P로 디코딩할 수 있다.
   
    <img src="img/14-6.jpeg" width="600"/>

    > 인코딩 함수 E와 디코더 함수 D는 역의 관계다.

### 14.3 대칭키 암호법
- 대칭키 암호법은 인코딩/디코딩할 때 암호키가 같다.
- 따라서 발신자와 수신자 모두 통신을 위해 비밀키를 똑같이 공유해야한다.
- ex) DES, Triple-DES, RC2, RC4 등

#### 14.3.1 키 길이와 열거 공격(Enumeration Attack)
- 대부분 인코딩, 디코딩 알고리즘은 공개적이므로 **비밀 키**는 절대 누설되면 안된다.
- 열거 공격 : 무차별로 모든 키 값을 대입해보는 공격
    - 만약 가능한 키가 몇가지 없다면 열거 공격으로 암호를 깰 수 있다.
    - 하지만 가능한 키가 아주 많다면 우주 수명만큼 시간을 들여야한다.
- 가능한 키 값의 개수는 **몇비트**인지, 얼마나 많은 키가 **유효**한지에 달려있다.
    - 대칭키 암호에서는 보통 모든 키가 유효하다.
    - 8비트 : 256가지
    - 40비트 : 2^40(약 1조)
    - 128비트 : 2^128
- 암호에 기반한 보안에서 **키의 길이**는 굉장히 중요하다.
    - 미국정부는 긴 키를 사용하는 암호화 SW 수출을 통제한다.
    - 적대적 조직이 이를 통해 깰 수 없는 암호문을 만들 수 있기 때문에
- DES 암호를 깨뜨리는데 걸리는 시간
    
    <img src="img/14-1.jpeg" width="600"/>
  
    > Triple-DES 키와 비슷한 크기인 128비트키는 누가 얼마를 들이든 실질적으로 깨뜨릴 수 없다고 알려짐. 

#### 14.3.2 공유키 발급하기
- 대칭키 암호의 단점은 발송자/수신자가 **둘 다 공유키를 가져야 한다는 것**이다.
- 만약 N개의 노드가 있고, 각 노드가 상대 N-1과 통신을 해야한다면? 대략 N^2개의 비밀키가 필요하다.
  
  > N(N-1)/2

- 관리해야하는 입장에서 지옥이다.

### 14.4 공개키 암호법
- 공개키 암호 방식은 두개의 비대칭 키(인코딩키, 디코딩키)를 사용한다.
- 인코딩 키는 모두를 위해 공개되어있지만 호스트만이 개인 디코딩 키를 알고 있다.

    <img src="img/14-9.jpeg" width="600"/>

- 서버는 키를 공개적으로 배포할 수 있다.
- 호스트는 누구나 사용할 수 있는 **공개키(인코딩키)** 를 할당받아 메시지를 인코딩할 수 있다.
    > 공개키를 사용하면, 호스트 마다 키를 할당해야하는 대칭키의 폭발적 증가(N^2)를 피할 수 있다.
- 하지만 **개인키(디코딩키)** 는 서버만 가지고 있기 때문에, 서버를 제외하고 그 누구도 메시지를 디코딩할 수 없다.
- 공개키 암호화 기술은 **보안 프로토콜**을 전세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 했다.

#### 14.4.1 RSA
RSA 알고리즘은 아래와 같은 내용을 알고있어도 절대 개인키를 계산할 수 없다.
- 공개키
- 가로채서 얻은 암호문의 일부
- 메시지와 그것을 암호화한 암호문

> 큰 숫자를 소수들로 분해하는 빠른 방법을 찾아 내는 것보다 어렵다고 합니다..

#### 14.2.2 혼성 암호 체계와 세션 키
- 비대칭 공개키는 누구나 공개키만 알면, 서버에 안전하게 메시지를 보낼 수 있다.
- 두 노드가 안전한 의사소통을 위해 개인키에 대한 협상을 할 필요가 없다.
- 하지만 공개키 암호 방식의 알고리즘은 **계산이 느리다.**
- 실제로는 **대칭과 비대칭 방식을 섞은 것**이 쓰인다.
- 대표적인 예
- 의사소통 채널 수립엔 편리한 **비대칭을 사용**하고, 만들어진 채널에 무작위 대칭키를 생성하여 교환 후 나머지 데이터를 암호화할 땐 빠른 **대칭키를 사용**한다.

### 14.5 디지털 서명
- 암호 체계는 메시지를 인코딩/디코딩뿐만 아니라, 누가 메시지를 썼고 그 메시지가 위조되지 않았음을 증명하기 위한 **메시지 서명**에 이용될 수 있다.

#### 14.5.1 서명은 암호 체크섬이다.
디지털 서명(digital signing) = 특별한 암호 체크섬
- 서명은 메시지 작성자가 누군지 알려준다.
    - 저자는 저자만의 개인키를 갖고 있기 때문에, 오직 저자만이 이 체크섬을 계산할 수 있다. 체크섬은 저자의 **개인 서명**처럼 동작한다.
- 서명은 메시지 위조를 방지한다.
    - 만약 송신 중 공격자가 메시지를 수정했다면, 체크섬은 더이상 그 메시지와 맞지 않게 된다.
    - 그리고 체크섬은 저자의 개인키에 관련되어 있기 때문에, 침입자는 올바른 체크섬을 날조할 수 없다.
- 보통 디지털 서명은 **비대칭 공개키**에 의해 생성된다. 개인키는 오직 저자만 알고 있기 때문에 `지문` 처럼 사용된다.

    <img src="img/14-10.jpg" width="600"/>
  
- 노드A는 가변 길이 메시지를 정제하여 고정된 길이의 **요약(digest)** 으로 만든다.
- 노드A는 그 요약에 사용자의 개인 키를 매개변수로 하는 `서명 함수 D`를 적용한다.
    - 올바른 서명 함수 = 서명자가 소유자임을 보여준다.
- 노드A는 이를 메시지 끝에 붙이고 노드 B에게 전송한다.
- 메시지를 받은 노드B는 원한다면 서명을 검사할 수 있다.
    - 서명에 공개키를 이용한 `역함수 E`를 적용하여 노드B가 가지고 있는 요약과 비교한다.
    - 일치하지 않는다면 위조되었거나, 저자는 노드A가 아닌것이다.
    
### 14.6 디지털 인증서

