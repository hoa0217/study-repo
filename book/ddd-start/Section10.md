# Chapter10 이벤트
## 10.1 시스템 간 강결합 문제

만약 도메인 객체에서 환불 기능을 실행하려면, 환불 기능을 제공하는 도메인 서비스(RefundService)를 파라미터로 전달받고 실행해야한다.

<img width="500" alt="스크린샷 2024-06-01 오후 10 48 48" src="https://github.com/hoa0217/study-repo/assets/48192141/1061e3c9-f389-4b28-bad2-8ddf546be5fb">

또는 응용 서비스에서 환불 기능을 실행할 수도 있다.

<img width="500" alt="스크린샷 2024-06-01 오후 10 49 29" src="https://github.com/hoa0217/study-repo/assets/48192141/4d695d5a-0f9e-4e31-9a56-8fcd4f9fe8e8">


RefundService는 외부에 있는 결제 시스템이 제공하는 환불 서비스를 호출한다.

이 때 아래와 같은 2가지 문제가 발생할 수 있다.

1. 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야할까? (Commit or Rollback)
  - 롤백하는 것이 맞아보이지만, 주문은 취소 상태로 변경하고 환불만 나중에 시도하는 방식으로 처리할 수도 있다.
2. 외부 서비스 응답 시간이 길어지면 대기시간이 길어진다. 즉, 외부 서비스 성능에 직접적인 영향을 받게 된다.

그 외에도 도메인 객체에 서비스를 전달하면, 설계상 문제가 나타날 수 있다.
- 주문 로직과 결제 로직이 섞이는 문제가 있다.
- 만약 환불 기능이 바뀌면, Order도 영향을 받게 된다.
- Order의 코드를 결제 도메인 때문에 변경할지도 모르는 상황은 좋지 않다.

<img width="500" alt="스크린샷 2024-06-01 오후 10 55 22" src="https://github.com/hoa0217/study-repo/assets/48192141/8b48be9c-98e6-4e4d-9ce5-34a4a574b025">

또한 기능을 추가할 때도 문제가 발생한다.
- 만약 주문을 취소한 뒤 환불뿐 아니라 취소했다는 내용을 통지해야한다면 어떻게 될까?
- 환불 도메인 서비스와 동일하게 파라미터로 통지 서비스를 받도록 구현하면 로직이 섞이는 문제가 커지고 트랜잭션 처리 또한 복잡해진다.
- 영향을 주는 외부 서비스가 두 개로 증가한다.

<img width="500" alt="스크린샷 2024-06-01 오후 10 58 47" src="https://github.com/hoa0217/study-repo/assets/48192141/ffeb497e-b5b1-40c1-80bf-59c4d3e01e68">

#### 위 문제들이 발생하는 이유는?
주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트 간의 **강결합(High Coupling)** 때문이다.
- 주문이 결제와 강하게 결합되어 있어 주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트가 영향을 받게되는 것이다.

이런 강한 결합을 없애려면, **이벤트**를 사용해야한다.
- 비동기 이벤트를 사용하면 두 시스템간 결합을 크게 낮출 수 있다.

## 10.2 이벤트 개요
이벤트: 과거에 벌어진 어떤 것
- 주문을 취소했다면, `주문을 취소했음 이벤트`가 발생한 것

이벤트가 발생한다는 것은 상태가 변경됐다는 것을 의미한다.
- 주문 취소됨 이벤트가 발생한 이유는 주문을 취소했기 때문이다.

이벤트는 발생에서 끝나지 않는다. 
- 이벤트가 발생하면 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다.
- UI 컴포넌트를 보면 이벤트 발생에서 끝나지 않고, 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다.

<img width="500" alt="스크린샷 2024-06-01 오후 11 03 50" src="https://github.com/hoa0217/study-repo/assets/48192141/e9454049-2e13-42c7-8129-61b9fca0d6dd">

도메인 모델에서도 UI 컴포넌트와 유사하게 도메인 상태 변경을 이벤트로 표현할 수 있다.
- `~ 할 때`, `~가 발생하면`, `만약 ~하면`과 같은 요구사항은 도메인의 상태 변경과 관련된 경우가 많고 이런 요구사항을 이벤트를 이용해서 구현할 수 있다.
- 예를 들어 주문을 취소할 때 `이메일을 보낸다`라는 요구사항에 `주문을 취소할 때`는 주문이 취소 상태로 바뀌는 것을 의미함으로 `주문 취소됨 이벤트`를 활용해서 구현할 수 있다.

### 10.2.1 이벤트 관련 구성요소

도메인 모델에 이벤트를 도입하려면 이벤트, 이벤트 생성 주체, 이벤트 디스패처(퍼블리셔), 이벤트 핸들러(구독자)를 구현해야 한다.

<img width="500" alt="스크린샷 2024-06-01 오후 11 07 17" src="https://github.com/hoa0217/study-repo/assets/48192141/d2a8345a-c1d4-43d6-9bf9-78d3fedab5d5">

#### 도메인 모델에서 이벤트 관련 구성 요소

이벤트 생성 주체: 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체
- 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다.

이벤트 핸들러(구독자): 이벤트 생성 주체가 발생한 이벤트에 반응
- 생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.

이벤트 디스패처(퍼블리셔): 이벤트 생성 주체와 이벤트 핸들러를 연결해주는 것
- 이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달한다.
- 이벤트를 전달받은 디스패처는 해당 이벤트를 처리할 수 있는 핸들러에 이벤트를 전파한다.
- 이벤트 디스패처의 구현방식에 따라 이벤트 생성과 처리를 동기/비동기로 실행하게된다.

### 10.2.2 이벤트의 구성

이벤트는 이벤트에 대한 정보를 담는다.
- 이벤트 종류: 클래스 이름으로 이벤트 종류를 표현
- 이벤트 발생 시간
- 추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

#### 예시
배송지 변경 시 발생하는 이벤트를 위한 클래스를 아래와 같이 작성할 수 있다.
```java
public class ShippingInfoChangedEvent {
    
    private String orderNumber;
    private long timestamp;
    private ShippingInfo newShippingInfo;
    
    // 생성자, getter
}
```
- Changed라는 과거 시제를 사용했다. 이는 현재 기준 과거에 벌어진것을 표현한다.

이 이벤트 발생 주체는 Order애그리거트다. 
- 애그리거트의 배송지 변경 기능을 구현한 메서드는 배송지 변경 후 이벤트를 발생시킨다.
```java
public class Order {
    
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped();
        setShippingInfo(newShippingInfo);
        Event.raise(new ShippingInfoChangedEvent(number, newShippingInfo));
    }
}
```
> Event.raise: 디스패처를 통해 이벤트를 전파하는 기능을 제공한다.

ShippingInfoChangedEvent를 처리하는 핸들러는 디스패처로부터 이벤트를 전달받아 필요 작업을 수행한다.
```java
public class ShippingInfoChangedHandler {
    
    @EventListener(ShippingInfoChangedEvent.class)
    public void handle(ShippingInfoChangedEvent evt) {
        shippingInfoSynchronizer.sync(evt.getOrderNumber(), evt.getNewShippingInfo());
        }
    }
}
```

이벤트는 이벤트 핸들러가 작업을 수행하는데 필요한 데이터를 담아야한다.
- 데이터가 부족하면, 핸들러는 필요한 데이터를 일긱 위해 관련 API를 호출하거나 DB에서 데이터를 직접 읽어와야한다.
- 하지만 그렇다고 이벤트 자체와 관련 없는 데이터를 포함할 필요는 없다.

### 10.2.3 이벤트 용도
이벤트는 두가지 용도로 쓰인다.
1. 트리거(Trigger): 도메인 상태가 바뀔 때 다른 후처리가 필요하면, 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.
  - 주문을 취소하면 환불을 처리해야 하는데, 이때 환불 처리를 위한 트리거로 주문 취소 이벤트를 사용할 수 있다.
  - <img width="500" alt="스크린샷 2024-06-01 오후 11 32 23" src="https://github.com/hoa0217/study-repo/assets/48192141/43fca91c-4e04-4c52-b8bb-0734f78366fb">

2. 서로 다른 시스템 간의 데이터 동기화
  - 배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야한다.
  - 주문 도메인은 배송지 변경 이벤트를 발생시키고, 이벤트 핸들러는 외부 배송 서비스와 배송지 정보를 동기화할 수 있다.

### 10.2.4 이벤트 장점
이벤트를 사용하면 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.

<img width="500" alt="스크린샷 2024-06-01 오후 11 35 54" src="https://github.com/hoa0217/study-repo/assets/48192141/31e46bca-3913-42b0-bde2-27c9b6c487be">

- 환불 실행 로직은 주문 취소 이벤트를 받는 이벤트 핸들러로 이동한다.
- 이벤트를 사용하여 주문 도메인에서 결제 도메인으로의 의존을 제거했다.

이벤트 핸들러를 사용하면 기능 확장도 용이하다.

<img width="500" alt="스크린샷 2024-06-01 오후 11 38 48" src="https://github.com/hoa0217/study-repo/assets/48192141/87bedb65-1b28-4917-92cc-f700456f46e9">

- 구매 취소 시 환불과 함께 이메일로 취소 내용을 보내고 싶다면 이메일 발송을 처리하는 핸들러를 구현하면된다.
- 기능을 확장해도 구매 취소 로직은 수정할 필요가 없다.

## 10.3 이벤트, 핸들러, 디스패처 구현

실제 이벤트와 관련된 코드를 구현해보자.
- 이벤트 클래스: 이벤트를 표현한다.
- 디스패처: 스프링이 제공하는 ApplicationEventPublisher를 이용한다.
- Events: 이벤트를 발행한다. 이벤트 발행을 위해 ApplicationEventPublisher를 사용한다.
- 이벤트 핸들러: 이벤트를 수신해서 처리한다. 스프링이 제공하는 기능을 사용한다.

### 10.3.1 이벤트 클래스
이벤트를 위한 상위 타입은 존재하지 않는다. 원하는 클래스를 이벤트로 사용하면 된다.
- 이벤트는 과거에 벌어진 상태 변화나 사건을 의미하므로, 이벤트 클래스 이름을 결정할 때 과거 시제를 사용해야하는 점만 유의하면 된다.
- OrderCanceledEvent: 클래스 이름 뒤로 접미사로 Event를 사용해서 명시적으로 표현할 수 도 있다.
- OrderCanceled: 간결함을 위해 과거 시제만 사용할 수 있다.

이벤트 클래스는 이벤트를 처리하는데 필요한 최소한의 데이터를 포함해야한다.
- 예를 들어 주문 취소됨 이벤트는 적어도 주문번호를 포함해야 관련 핸들러에서 후속 처리를 할 수 있다.

모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면, 관련 상위 클래스를 만들고 각 이벤트 클래스가 상속받도록 할 수 있다.

<img width="500" alt="스크린샷 2024-06-01 오후 11 45 26" src="https://github.com/hoa0217/study-repo/assets/48192141/99f850b1-e431-4557-877b-29e56fe1d07f">

### 10.3.2 Events클래스와 ApplicationEventPublisher

스프링컨테이너는 ApplicationEventPublisher도 된다.Events 클래스는 ApplicationEventPublisher를 사용해서 이벤트를 발생시킨다.

<img width="500" alt="스크린샷 2024-06-02 오전 1 09 54" src="https://github.com/hoa0217/study-repo/assets/48192141/4dcc261d-617d-491b-8684-bd64392603a7">

- Events 클래스는 ApplicationEventPublisher가 제공하는 publishEvent 메서드를 이용하여 이벤트를 발생시킨다.

<img width="500" alt="스크린샷 2024-06-02 오전 1 16 46" src="https://github.com/hoa0217/study-repo/assets/48192141/15e7f908-53a8-4104-b596-7aa883429d08">

- 그리고 Events 클래스에 ApplicationEventPublisher를 전달하기 위해 스프링 설정을 위와 같이 작성한다.
- `eventsInitializer()`는 스프링 빈 객체를 초기화할 때 사용하는 인터페이스로, 이 기능을 사용해서 Events 클래스를 초기화한다.
- 참고로 ApplicationContext는 ApplicationEventPublisher를 상속하고 있다.

### 10.3.3 이벤트 발생과 이벤트 핸들러
위에서 구현한 Events의 `raise()`메서드를 이용하여 이벤트를 발생시킨다.

<img width="500" alt="스크린샷 2024-06-02 오전 1 20 19" src="https://github.com/hoa0217/study-repo/assets/48192141/16e0fae1-c297-4afe-956e-77fad7e10789">

이벤트를 처리할 핸들러는 스프링이 제공하는 @EventListener 애너테이션을 사용해 구현한다.

<img width="500" alt="스크린샷 2024-06-02 오전 1 21 06" src="https://github.com/hoa0217/study-repo/assets/48192141/8ba7acb0-ee86-4106-882e-901bbf235121">

ApplicationEventPublisher의 publishEvent메서드를 실행할 때 OrderCanceledEvent 타입 객체를 전달하면, OrderCanceledEvent.class 값을 갖는 @EventListener 애너테이션을 붙인 메서드를 찾아 실행한다.

### 10.3.4 흐름 정리

<img width="500" alt="스크린샷 2024-06-02 오전 1 23 22" src="https://github.com/hoa0217/study-repo/assets/48192141/6af248bd-1990-4246-bc1e-e5a18dead598">

1. 도메인 기능을 실행한다.
2. 도메인 기능은 Events.raise()를 이용해서 이벤트를 발생시킨다.
3. Events.raise()는 스프링이 제공하는 ApplicationEventPublisher를 이용해서 이벤트를 출판한다.
4. ApplicationEventPublisher는 @EventListener(이벤트타입.class)애너테이션이 붙은 메서드를 찾아 실행한다.

코드 흐름을 보면 응용 서비스와 동일한 트랜잭션 범위에서 이벤트 핸들러를 실행하고 있다.
- 즉, 도메인 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 실행된다.

## 10.4 동기 이벤트 처리 문제

이벤트를 사용하여 강결합 문제는 해소했지만, 외부 서비스에 영향을 받는 문제는 해결되지 못했다.

<img width="500" alt="스크린샷 2024-06-02 오전 1 27 39" src="https://github.com/hoa0217/study-repo/assets/48192141/5f392546-ba6e-45a1-ae39-45daa9f6fd9f">

해당 코드에서 refundService.refund()가 외부 환불 서비스와 연동한다고 가정해보자.
- 만약 외부 환불 기능이 갑자기 느려지면 cancel()메서드도 함께 느려진다.
- 이는 외부 서비스의 성능 저하가 바로 내 시스템의 성능 저하로 연결된다는 것을 의미한다.

성능 저하뿐 아니라 트랜잭션도 문제가 된다.
- refundService.refund()에서 익셉션이 발생하면 cancel()메서드도 트랜잭션을 롤백해야할까?
- 트랜잭션을 롤백하면 구매취소기능을 롤백하는 것이므로 구매 취소가 실패하는 것과 같다.

> 외부 환불 서비스 실행에 실패했다고 해서 반드시 트랜잭션을 롤백해야할까? 일단 구매 자체는 취소하고 환불만 재처리하거나 수동으로 처리할 수 있다.

외부 시스템과 연동을 동기로 처리할 때 발생하는 성능과 트랜잭션 범위 문제의 해결방법은
1. 이벤트를 비동기로 처리하거나
2. 이벤트와 트랜잭션을 연계하는 것이다.

## 10.5 비동기 이벤트 처리
`A하면 이어서 B하라`는 요구사항은 실제 `A하면 최대 언제까지 B하라`인 경우가 많다.
- 즉, 일정 시간 안에만 후속 조치를 처리하면 되는 경우가 적지않다.
- 게다가 B를 하는데 실패하면 일정 간격으로 재시도를 하거나 수동 처리를 해도 상관없는 경우가 있다.
- 만약 `회원 가입 신청을 하면 인증 이메일을 보내라`는 요구사항에서 `인증 이메일을 보내라`기능은  `회원 가입신청함 이벤트`를 처리하는 핸들러에서 보낼 수 있다.
- 따라서 위 요구사항은 이벤트를 비도익로 처리하는 방식으로 구현할 수 있다.
- 다시말해 A이벤트가 발생하면 별도 스레드로 B를 수행하는 핸들러를 실행하는 방식으로 요구사항을 구현할 수 있다.

이벤트를 비동기로 구현할 수 있는 방법 4가지를 소개한다.
- 로컬 핸들러를 비동기로 실행하기
- 메시지큐를 사용하기
- 이벤트 저장소와 이벤트 포워더 사용하기
- 이벤트 저장소와 이벤트 제공 API 사용하기

### 10.5.1 로컬 핸들러 비동기 실행

스프링이 제공하는 @Async 애너테이션을 사용하면 손쉽게 비동기로 이벤트 핸들러를 실행할 수 있다.
- @EnableAsync 애너테이션을 사용해서 비동기 기능을 활성화한다.
- 이벤트 핸들러 메서드에 @Async 애너테이션을 붙인다.

@EnableAsync 애너테이션은 스프링 비동기 실행 기능을 활성화한다.
```java
@SpringBootApplication
@EnableAsync
public class ShopApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(ShopApplication.class, args);
    }
}
```
그리고 비동기로 실행할 이벤트 핸들러 메서드에 @Async 애너테이션만 붙이면 된다.

```java
@Service
public class OrderCanceledEventHandler {
    
    @Async
    @EventListener(OrderCancelEvent.class)
    public void handle(OrderCancelEvent event) {
        refundService.refund(event.getOrderNumber());
    }
}
```

스프링은 OrderCancelEvent발생 시 handle메서들르 별도 스레드를 이용해 비동기로 실행한다.

### 10.5.2 메시징 시스템을 이용한 비동기 구현
또 다른 방법은 메시징 시스템을 사용하는 것이다.

<img width="500" alt="스크린샷 2024-06-02 오전 1 52 50" src="https://github.com/hoa0217/study-repo/assets/48192141/68fe56dd-bfbe-4e8a-8e39-cb0e090dd1aa">

- 이벤트가 발생하면 이벤트 디스패처는 이벤트를 메시징 시스템(Kafka, RabbitMQ 등)에 보낸다.
- 메시지 큐는 이벤트를 메시지 리스너에 전달하고, 메시지 리스너는 알맞는 이벤트 핸들러를 이용해서 이벤트를 처리한다.
- 이때 이벤트를 메시지 큐에 저장하는 과정과 메시지 큐에서 이벤트를 읽어와 처리하는 과정은 별도 스레드나 프로세스로 처리된다.
- 필요하다면, 이벤트 발생 도메인 기능과 메시지 큐에 이벤트를 저장하는 절차를 한 트랜잭션으로 묶어야 한다.
- 도메인 기능을 실행한 결과를 DB에 반영하고 이벤트를 메시지 큐에 저장하는 것을 같은 트랜잭션 범위에서 실행하려면 **글로벌 트랜잭션**이 필요하다.

메시지 큐를 사용하면, 보통 이벤트 발생 주체와 이벤트 핸들러가 별도 프로세스에서 동작한다.
- 이는 이벤트 발생 JVM과 이벤트 처리 JVM이 다르다는 것을 의미한다.
- 물론 한 JVM에서 이벤트 발생 주체와 이벤트 핸들러가 메시지 큐를 이용해서 이벤트를 주고받을 수 있지만,
- 동일 JVM에서 비동기 처리를 위해 메시지 큐를 사용하는 것은 시스템을 복잡하게 만든다.

메세지 큐는 글로벌 트랜잭션 지원과 함께 클러스터와 고가용성을 지원하기 때문에 안정적으로 메시지를 전달할 수 있는 장점이 있다.
- 다양한 개발언어와 통신 프로토콜도 지원한다.

가장 많이 사용되는 메시지큐는 카프카이다.
- 카프카는 글로벌 트랜잭션을 지원하진 않지만, 다른 메시징 시스템에 비해 높은 성능을 보여준다.

### 10.5.3 이벤트 저장소를 이용한 비동기 처리
또 다른 방법은 이벤트를 일단 DB에 저장한 뒤, 별도 프로그램을 이용해 이벤트 핸들러에 전달하는 것이다.

<img width="500" alt="스크린샷 2024-06-02 오전 2 05 56" src="https://github.com/hoa0217/study-repo/assets/48192141/0f5e1bf3-75f0-4545-962c-d6943849c93d">

- 이벤트가 발생하면 핸들러는 스토리지에 이벤트를 저장한다.
- 포워더는 주기적으로 이벤트 저장소에서 이벤트를 가져와 이벤트 핸들러를 실행한다.
- 포워더는 별도 스레드를 이용하기 때문에 이벤트 발행과 처리가 비동기로 처리된다.

해당 방식은 **도메인의 상태**와 **이벤트 저장소**로 동일한 DB를 사용한다.
- 즉, 도메인 상태 변화와 이벤트 저장이 로컬 트랜잭션으로 처리된다.
- 이벤트를 물리적 저장소에 보관하기 때문에, 이벤트 핸들러가 이벤트 처리에 실패할 경우 포워더는 다시 저장소에서 이벤트를 읽어와 핸들러를 실행하면된다.

이벤트 저장소를 이용한 두번째 방법은 이벤트를 외부에 제공하는 API를 사용하는 것이다.

<img width="500" alt="스크린샷 2024-06-02 오후 5 04 11" src="https://github.com/hoa0217/study-repo/assets/48192141/cf05eb29-e220-465b-9c2f-840f750c9070">

- 포워더 방식은 포워더를 이용해 이벤트를 외부에 전달한다면, API 방식은 외부 핸들러가 API 서버를 통해 이벤트 목록을 가져간다.
- 포워더 방식은 이벤트를 어디까지 처리했는지 추적을 포워더가 한다.
- API 방식은 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 기억해야 한다.

#### 이벤트 저장소 구현
포워더/API 방식 모두 이벤트 저장소를 사용하므로 저장소를 구현해보자.

<img width="500" alt="스크린샷 2024-06-02 오후 5 06 19" src="https://github.com/hoa0217/study-repo/assets/48192141/bef077cb-fd0c-4373-9ef6-6ffaf86687e5">

- EventEntry: 이벤트 저장소에 보관할 데이터. 이는 
  - id: 이벤트를 식별자
  - type: 이벤트 타입
  - contentType: 직렬화한 데이터 형식
  - payload: 이벤트 데이터
  - timestamp: 이벤트 시간
- EventStore: 이벤트를 저장/조회하는 인터페이스 제공
- JdbcEventStore: JDBC를 이용한 EventStore 구현 클래스
- EventApi: REST API를 이용해서 이벤트 목록을 제공하는 컨트롤러

#### EventEntry
```java
public class EventEntry {

    private Long id;
    private String type;
    private String contentType;
    private String payload;
    private long timestamp;
    
    // 생성자, getter
}
```

#### EventStore
- 이벤트 객체를 직렬화해서 payload에 저장한다.
- 이 때 JSON으로 직렬화했다면, contentType값으로 `application/json`을 갖는다.

```java
public insterface EventStore {
    
    void save(Object event);
    List<EventEntry> get(long offset, long limit);
}
```

- 이벤트는 과거에 벌어진 사건이므로 데이터가 변경되지 않는다.
- 따라서 EventSorte는 새로운 이벤트 추가 및 조회 기능만 제공하고 수정기능은 제공하지 않는다.
- 위 인터페이스를 구현한 JdbcEventStore는 아래와 같다.

<img width="500" alt="스크린샷 2024-06-02 오후 5 26 35" src="https://github.com/hoa0217/study-repo/assets/48192141/12d99a28-97b7-4378-8949-87231c319196">

<img width="500" alt="스크린샷 2024-06-02 오후 5 27 13" src="https://github.com/hoa0217/study-repo/assets/48192141/e682a5d2-cfae-4b69-b3e2-8e6dd4778296">

<img width="500" alt="스크린샷 2024-06-02 오후 5 27 31" src="https://github.com/hoa0217/study-repo/assets/48192141/3ef70a98-d55e-4084-8326-a4fe3ca339da">

- `save()`는 파라미터로 전달받은 event객체를 JSON 문자열로 변환해서 payload로 전달하고 contentType은 `application/json`로 설정했다.
- `get()`는 MySQL limit을 이용하여 id순으로 정렬했을 때 offset 파라미터로 지정한 이벤트부터 limit 개수만큼 데이터를 조회한다.
- EventEntry테이블 DDL은 아래와 같다.

<img width="500" alt="스크린샷 2024-06-02 오후 5 31 05" src="https://github.com/hoa0217/study-repo/assets/48192141/bc994efa-2e40-4cab-80cd-40a2ba15e15f">

#### 이벤트 저장을 위한 이벤트 핸들러 구현

이벤트 저장소를 위해 기반이 되는 클래스는 모두 구현했으므로, 발생한 이벤트를 이벤트 저장소에 추가하는 **이벤트 핸들러**를 구현하자.

<img width="500" alt="스크린샷 2024-06-02 오후 5 32 57" src="https://github.com/hoa0217/study-repo/assets/48192141/17983743-0335-4b3b-83c2-5b913713d369">

- EventStoreHandler의 `handle()`은 `eventStore.save()`메서드를 이용하여 객체를 저장한다.

#### REST API 구현

해당 구현은 offset과 limit의 웹 요청 파라미터를 이용하여 EventStore.get을 실행하고 그 결과를 JSON으로 리턴한다.

<img width="500" alt="스크린샷 2024-06-02 오후 5 34 37" src="https://github.com/hoa0217/study-repo/assets/48192141/ad605bdd-af8f-433e-8ba2-2b1c415ae2e2">

해당 API를 호출하면 JSON 형식으로 EventEntry 목록을 구할 수 있다.

<img width="500" alt="스크린샷 2024-06-02 오후 5 35 33" src="https://github.com/hoa0217/study-repo/assets/48192141/c03f8bd5-4e5c-4791-b1f5-90c6e4bd0ca6">

API 클라이언트는 일정 간격으로 아래 과정을 실행한다.

1. 가장 마지막에 처리한 데이터의 offset인 lastOffset을 구한다. 
  - 저장한 lastOffset이 없으면 0을 사용한다.
2. 마지막에 처리한 lastOffset을 사용해서 API를 실행한다.
3. API 결과로 받은 데이터를 처리한다.
4. offset + 데이터 개수를 lastOffset으로 저장한다.

> lastOffset을 저장하는 이유는 같은 이벤트를 중복해서 처리하지 않기 위해서이다.

<img width="500" alt="스크린샷 2024-06-02 오후 5 40 59" src="https://github.com/hoa0217/study-repo/assets/48192141/59482f5c-7fe6-442c-929d-a3808fe7a9fa">

- 클라이언트 API를 이용해서 언제든 원하는 이벤트를 가져올 수 있기 때문에
- 이벤트 처리에 실패하면 다시 실패한 이벤트부터 읽어와 이벤트를 재처리할 수 있다.
- API 서버에 장애가 발생한 경우에도 주기적으로 재시도를 하여 API서버가 살아나면 이벤트를 처리할 수 있다.

#### 포워더 구현
- 포워더는 일정 주기로 EventStore에서 이벤트를 읽어와 이벤트 핸들러에 전달하면된다.
- API 방식 클라이언트와 마찬가지로 마지막으로 전달한 이벤트의 offset을 기억해두었다가
- 다음 조회 시점에 마지막으로 처리한 offset부터 이벤트를 가져오면 된다.

<img width="500" alt="스크린샷 2024-06-02 오후 7 53 53" src="https://github.com/hoa0217/study-repo/assets/48192141/0a4ceb45-3be8-4051-8507-d702e6ac6166">

<img width="500" alt="스크린샷 2024-06-02 오후 7 54 11" src="https://github.com/hoa0217/study-repo/assets/48192141/3c5ad724-2f60-4632-b38d-41d6555f09ab">

- 18~28행은 이벤트를 읽어와 전달하는 기능을 구현한다.
- 20행: 읽어올 다음 offset을 구한다.
- 21행: 이벤트 저장소에서 offset부터 limitSize 만큼 이벤트를 구한다.
- 22행: 구한 이벤트가 존재하는지 검사한다.
- 23행: 구한 이벤트가 존재하면 sendEvent()메서드를 이용해 이벤트를 전달한다.
- 24행~26행: 처리한 이벤트 개수가 0보다 크면 다음 읽어올 offset을 저장한다.

> getAndSend()메서드를 주기적으로 실행하기 위해 스프링의 @Scheduled애너테이션을 사용함.

- OffsetStore의 경우, offset값을 DB테이블에 저장하거나 로컬 파일에 보관하여 마지막 offset값을 물리적 저장소에 보관하면 된다.
- EventSender의 경우 외부 메시징 시스템에 이벤트를 전송하거나 원하는 핸들러에 이벤트를 전달하면된다.
- 이벤트 처리 중 익셉션이 발생하면 그대로 전파하여 다음 주기에 getAndSend()메서드 실행 시 재처리할 수 있도록 한다.

## 10.6 이벤트 적용 시 추가 고려 사항

#### 1. 이벤트 소스를 EventEntry에 추가할 지 여부
- EventEntry는 이벤트 발생 주체에 대한 정보를 갖지 않는다.
- 따라서 `Order가 발생시킨 이벤트만 조회하기`와 같이 특정 주체가 발생시킨 이벤트만 조회하는 기능을 구현할 수 없다.
- 이 기능을 구현하려면 이벤트에 발생 주체 정보를 추가해야 한다.

#### 2. 포워더에서 전송 실패를 얼마나 허용할 것이냐
- 포워더는 이벤트 전송에 실패하면 실패한 이벤트부터 다시 읽어와 전송을 시도한다.
- 그런데 특정 이벤트에서 계속 실패하게 되면? 그 이벤트때문에 나머지 이벤트를 전송할 수 없다.
- 따라서 재전송 횟수 제한을 두어야한다.

> 처리에 실패한 이벤트를 생략하지 않고 별도 실패용 DB나 메시지큐에 저장하기도한다. 물리적 저장소에 남겨두면 이후 실패 이유 분석이나 후처리에 도움이 된다.

#### 3. 이벤트 손실
- 이벤트 저장소를 사용하는 방식은 이벤트 발생과 이벤트 저장을 한 트랜잭션으로 처리하기 때문에 트랜잭션 성공 시 이벤트 저장소에 보관된다는 것을 보장할 수 있다.
- 반면 로컬 핸들러를 이용하여 이벤트를 비동기로 처리할 경우, 이벤트 처리에 실패하면 이벤트를 유실하게 된다.

#### 4. 이벤트 순서
- 이벤트 발생 순서대로 외부 시스템에 전달해야할 경우, 이벤트 저장소를 사용하는 것이 좋다.
- 이벤트 저장소는 순서대로 저장하고 순서대로 이벤트 목록을 제공하기 때문이다.
- 반면 메시징 시스템은 사용기술에 따라 이벤트 발생 순서와 메시지 전달순서가 다를 수 있다.

#### 5. 이벤트 재처리
- 동일 이벤트를 다시 처리해야할 때 이벤트를 어떻게 할지 결정해야한다.
- 쉬운 방법은 마지막으로 처리한 이벤트의 순번을 기억해 두었다가 이미 처리한 순번의 이벤트가 도착하면 해당 이벤트는 처리하지 않고 무시하는 것이다.
- 이 외에 이벤트를 멱등으로 처리하는 방법이 있다.

> **멱등성**   
> - 연산을 여러번 적용해도 결과가 달라지지 않는 성질을 멱등성이라고 한다.
> - 이벤트 처리가 동일 이벤트를 한번 적용하나 여러번 적용하나 시스템이 같은 상태가 되도록 핸들러를 구현할 수 있다.
> - 예를 들어 배송지 정보 변경 이벤트를 받아 주소를 병경하는 핸들러는 그 이벤트를 한번 처리하나 여러번 처리하나 동일 주소를 갖는다.
> - 같은 이벤트를 여러번 척용해도 결과가 같으므로 이벤트 핸들러는 멱등성을 갖는다.
> - 이처럼 이벤트 핸들러가 멱등성을 가지면 시스템 장애로 같은 이벤트가 중복해서 발생해도 결과적으로 동일한 상태가 된다.
> - 이는 이벤트 중복 발생/처리에 대한 부담을 줄여준다.

### 10.6. 이벤트 처리와 DB 트랜잭션 고려
이벤트를 처리할 때 DB 트랜잭션을 함께 고려해야한다.

#### 예시
- 주문 취소 기능은 주문 취소 이벤트를 발생시킨다.
- 주문 취소 이벤트 핸들러는 환불 서비스에 환불 처리를 요청한다.
- 환불 서비스는 외부 API를 호출해서 결제를 취소한다.

이를 모두 동기로 처리하면 실행 흐름은 아래와 같다.

<img width="500" alt="스크린샷 2024-06-02 오후 8 09 53" src="https://github.com/hoa0217/study-repo/assets/48192141/ba9f143e-2a6b-4083-8ddd-b4464e000532">

- 하지만 만약 12번과정까지 성공하고 13번과정에서 DB를 업데이트하는데 실패한다면?
- 결제는 취소됐는데 DB에는 주문이 취소되지 않는 상태로 남게된다.

이벤트를 비동기로 처리할 때도 DB 트랜잭션을 고려해야한다.

<img width="500" alt="스크린샷 2024-06-02 오후 8 11 03" src="https://github.com/hoa0217/study-repo/assets/48192141/8b349afe-43df-43f5-bbf5-4bfa1dd7a41e">

- 이벤트 핸들러를 호출하는 5번 과정은 비동기로 실행한다.
- DB 업데이트와 트랜잭션을 다 커밋한 뒤 환불 로직인 11~13번 과정을 실행한다.
- 만약 12번 과정에서 외부 API 호출에 실패하면 DB에는 주문이 취소되었지만 결제는 취소되지 않는 상태로 남는다.

이벤트를 동기/비동기로 하든 이벤트 처리 실패와 트랜잭션 실패는 함께 고려해야한다.
- 트랜잭션 실패/이벤트 처리 실패를 모두 고려하면 복잡해지므로 경우의 수를 줄이면 도움이 된다.
- 경우의 수를 줄이는 방법은 트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 것이다.

스프링 @TransactionalEventListener 애너테이션을 지원한다.
- 이는 스프링 스랜잭션 상태에 따라 이벤트 핸들러를 실행할 수 있게 한다.

<img width="500" alt="스크린샷 2024-06-02 오후 8 13 39" src="https://github.com/hoa0217/study-repo/assets/48192141/6f3417b7-5375-4e34-bba3-b3040688674e">

- phase 속성 값으로 TransactionPhase.AFTER_COMMIT을 지정했다.
- 이는 스프링 트랜잭션 커밋에 성공한 뒤 핸들러 메서드를 실행한다.
- 중간에 에러가 발생하여 트랜잭션이 롤백되면 핸들러 메서드는 실행하지 않는다.
- 이 기능을 사용하면 이벤트 핸들러는 실행했는데 트랜잭션이 롤백되는 상황은 발생하지 않는다.

이벤트 저장소로 DB를 사용해도 동일한 효과를 볼 수 있다.
- 이벤트 발생 코드와 이벤트 저장을 한 트랜잭션으로 처리하면 된다.
- 이렇게 하면 트랜잭션이 성공할 때만 이벤트가 DB에 저장되므로, 실패했는데 이벤트 핸들러가 실행되는 상황은 발생하지 않는다.

트랜잭션이 성공할 때만 이벤트 핸들러를 실행하면, 이제 이벤트 처리 실패만 고민하면된다.
- 이벤트 특성에 따라 재처리 방식을 결정하면 된다.





