# Chapter6 응용 서비스와 표현 영역
## 6.1 표현 영역과 응용 영역

응용영역과 표현영역이 사용자와 도메인을 연결해 주는 매개체 역할을 한다.

표현 영역: 사용자의 요청을 해석한다. 
- 사용자가 웹브라우저에 데이터를 입력하여 전송하면, 요청 파라미터를 포함한 HTTP 요청을 표현 영역에 전달한다.
- 표현영역은 URL, 요청파라미터, 쿠키, 헤더 등을 이용해 사요자가 실행하고 싶은 기능을 판별하여 그 기능을 제공하는 응용 서비스를 실행한다.

응용 영역: 실제 사용자가 원하는 기능을 제공한다.
- 회원 가입을 요청했다면, 그 요청을 위한 기능을 제공하는 주체는 응용 서비스에 위치한다.

<img width="500" alt="스크린샷 2024-05-19 오후 7 47 48" src="https://github.com/hoa0217/study-repo/assets/48192141/51d96a2d-ad07-4981-bb6a-8af10ef9a9cf">

- 응용 서비스의 메서드가 요구하는 파라미터와 표현 영역이 사용자로부터 전달받은 데이터는 형식이 일치하지 않기 때문에, 표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변환한다.
- 그 후 응용 서비스를 실행한 뒤, 표현 영역은 실행 결과를 사용자에게 알맞은 형식으로 응답한다. (HTML or JSON 등)

사용자와 상호작용은 표현 영역이 처리하기 때문에, 응용 서비스는 표현영역에 의존하지 않는다.
- 사용자가 REST API를 호출하는지 TCP 소켓을 사용하는지 알 필요가 없다.
- 단지, 기능 실행에 필요한 입력값을 받고 실행 결과만 리턴하면 된다.

## 6.2 응용 서비스의 역할

응용 서비스는 사용자(클라이언트)가 요청한 기능을 실행한다.
- 즉, 사용자 요청을 처리하기 위해 리포지터리에서 도메인 객체를 가져와 사용한다.
- 표현영역입장에서 응용서비스는 도메인 영역과 표현영역을 연결해주는 창구역할을 한다.

응용 서비스는 주로 도메인 객체 간의 흐름을 제어하기 때문에 아래와 같은 형태를 갖는다.

<img width="500" alt="스크린샷 2024-05-19 오후 7 51 43" src="https://github.com/hoa0217/study-repo/assets/48192141/50be2807-42e0-43f2-91db-4671073f1684">

응용 서비스가 복잡하다면, 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다.
- 이는 코드 중복, 로직 분상 등 코드 품질에 안좋은 영향을 줄 수 있다.

응용 서비스는 트랜잭션 처리도 담당한다.
- 도메인의 상태 변경을 트랜잭션으로 처리한다.
- 만약 트랜잭션 범위에서 실행되지 않으면, DB에 반영 도중 문제 발생 시 일부 데이터만 반영이 되어버리는 일이 발생할 수 있다. -> 데이터 일관성 깨짐
- 따라서 트랜잭션 범위에서 응용 서비스를 실행해야 한다.

### 6.2.1 도메인 로직 넣지 않기

도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면, 코드 품질에 문제가 발생한다.

1. 코드의 응집성이 떨어진다.
  - 도메인 데이터와 그 데이터를 조작하는 도메인 로직이 서로 다른영역에 위치한다는 것은 도메인 로직을 파악하기 위해 여려 영역을 분석해야 한다는 것을 의미한다.
2. 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다.

<img width="500" alt="스크린샷 2024-05-19 오후 7 55 53" src="https://github.com/hoa0217/study-repo/assets/48192141/33b388d0-79b2-4301-b409-5329ba6723a9">

위 문제는 결과적으로 코드 변경을 어렵게 만든다.
- 소프트웨어가 가져야할 중요한 경쟁 요소 중 하나가 변경 용이성인데, 변경이 어렵다는 것은 그만큼 SW 가지차 떨어진다는 것을 의미한다.
- 따라서 도메인 로직을 도메인 영역에 모아 코드 중복을 줄이고 응집도를 높이자.

## 6.3 응용 서비스의 구현

- 응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할 -> 디자인 패턴에서 파사드와 같은 영할을 한다.
- 응용 서비스 자체는 복잡한 로직을 수행하지 않기 때문에 구현이 어렵지 않다.
- 따라서 구현 시 고려 사항과 구현 기술의 연동을 알아보자.

### 6.3.1 응용 서비스의 크기
보통 응용 서비스는 아래 방법 중 한가지 방식으로 구현한다.
- 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
- 구분되는 기능별로 응용 서비스 클래스 따로 구현하기

#### 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기

<img width="500" alt="스크린샷 2024-05-19 오후 8 03 04" src="https://github.com/hoa0217/study-repo/assets/48192141/62c34e31-a9eb-417c-a26b-9bc5d7bfb926">

<img width="500" alt="스크린샷 2024-05-19 오후 8 03 30" src="https://github.com/hoa0217/study-repo/assets/48192141/838fcf83-51a1-4343-b9f8-5cc7868b78aa">

- 첫번째 방법은 한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다는 장점이 있다.
- 하지만, 클래스의 크기(코드 줄 수)가 커진다는 단점이 존재한다.
- 코드 크기가 커지면, 연관성이 적은 코드가 한 크래스에 함께 위치할 가능성이 높아지며 결과적으로 관련없는 코드가 뒤섞여 코드 이해를 방해한다.
  - 암호 초기화 후 사용자에게 통지하기위해 Notifier를 사용하지만, 이는 암호 변경에는 필요하지 않다. 하지만 Notifier는 필드로 존재한다.
- 또한 한 클래스에 코드가 모이면 분리하는 것이 좋은 상황임에도 습관적으로 기존에 존재하는 클래스에 억지로 끼워 넣게 된다.

#### 구분되는 기능별로 응용 서비스 클래스 따로 구현하기

<img width="500" alt="스크린샷 2024-05-19 오후 8 03 50" src="https://github.com/hoa0217/study-repo/assets/48192141/ee316d6f-f125-426a-a2ad-c3df63f27191">

- 한 응용 서비스 클래스에서 한 개 내지 2~3개의 기능을 구현한다. 위와 같이 암호 변경 기능만을 위해 응용 서비스 클래스를 별도로 구현한다.
- 이 방식을 사용하면, 클래스 개수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해 코드 품질을 일정 수준으로 유지하는데 도움이 된다.
- 또한 각 클래스별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않는다.
- 각 기능마다 동일한 로직을 구현할 경우엔, 별도 클래스에 로직을 구현하여 코드가 중복되는 것을 방지할 수 있따.

> 저자는 구분되는 기능을 별도의 서비스 클래스로 구현하는 방식을 선호함. 

### 6.3.2 응용 서비스의 인터페이스와 클래스
응용 서비스 구현 시 인터페이스가 필요할까?

인터페이스가 필요한 몇가지 상황이 있는데, 그 중 구현 클래스가 여러개인 경우이다.
- 런타임에 구현객체를 교체해야할 때 인터페이스를 유용하게 사용할 수 있다.
- 하지만, 그런 상황은 거의 없고 한 응용 서비스의 구현 클래스가 두개인 경우도 드물다.
- 따라서, 인터페이스가 명확하게 필요하기 전까지 응용 서비스에 대한 인터페이스를 작성하는 것은 좋은 선택이라 볼 수 없다.

TDD를 즐겨하고 표현 영역부터 개발을 시작하면, 미리 응용 서비스를 구현할 수 없으므로 응용 서비스의 인터페이스부터 작성하게 된다.
- 만약 스프링 MVC 컨트롤러를 TDD로 먼저 개발하면, 응용 서비스 인터페이스를 이용해 컨트롤러 구현을 완성해나갈 수 있다.

만약 도메인 영역이나, 응용 영역 개발을 먼저 시작하면 응용 서비스 클래스가 먼저 만들어진다.
- 그리고 표현 영역의 단위 테스트를 위해 응용 서비스 클래스 가짜 객체가 필요한데 이를 위해 인터페이스를 추가할 수 있다.
- 하지만 Mockito와 같은 도구로 테스트용 대역객체를 만들 수 있기 때문에 인터페이스 업이도 표현영역을 테스트할 수 있다.

이는 결과적으로 인터페이스 필요성을 약화 시킨다,

### 6.3.3 메서드 파라미터와 값 리턴
응용 서비스가 제공하는 메서드는 도메인을 이용하여 기능을 실행하는데, 필요한 값을 파라미터로 전달받아야 한다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 12 20" src="https://github.com/hoa0217/study-repo/assets/48192141/61ccc495-5343-4246-8de5-e1e613687c59">

스프링 MVC와 같은 웹프레임워크는 웹 요청 파라미터를 자바 객체로 변환하는 기능을 제공하므로, 파라미터가 2개이상 존재하면 별도 클래스를 사용하는 것이 편리하다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 13 08" src="https://github.com/hoa0217/study-repo/assets/48192141/78e5a56c-1f7f-4685-8d98-22d968a04e8f">

응용 서비스 결과를 표현영역에서 사용해야하면, 응용 서비스 메서드 결과로 필요한 데이터를 리턴한다.
그리고 표현영역에서 해당 리턴값을 사용해 사용자에게 알맞은 결과를 보여준다.
- 식별자나 애그리거트 객체 그대로를 리턴할 수 있음.

<img width="500" alt="스크린샷 2024-05-19 오후 8 14 46" src="https://github.com/hoa0217/study-repo/assets/48192141/548a375e-7d50-4208-b3c2-cc82c05d95bd">

<img width="500" alt="스크린샷 2024-05-19 오후 8 15 23" src="https://github.com/hoa0217/study-repo/assets/48192141/4ff5b48c-0adf-453f-a5d0-3055ce3128b2">

애그리거트 자체를 리턴하면 코딩이 편할 수 는 있지만, 도메인 로직 실행이 응용 서비스와 표현 영역 두곳에서 할 수 있게 된다.
- 이는 응용서비스와 표현영역에 기능 실행 로직을 분산시켜 코드 응집도를 낮추는 원인이된다.
- 따라서 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 응집도를 높이는 확실한 방법이다.

### 6.3.4 표현 영역에 의존하지 않기

응용 서비스 파라미터 타입 결정시, 표현 영역과 관련된 타입을 사용하면 안된다는 점이다.
- 아래와 같이 HttpServletRequest를 응용 서비스에 파라미터로 전달하면 안된다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 17 40" src="https://github.com/hoa0217/study-repo/assets/48192141/31b3b342-030d-4ffc-a87c-5ad73807d495">

응용서비스에서 표현 영역에 대한 의존이 발생하면, 응용 서비스 단독으로 테스트하기 어려워진다.
- 또한 표현 영역의 구현 변경 시 응용 서비스도 함께 변경해야하는 문제가 발생한다.
- 그리고 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수 있다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 19 26" src="https://github.com/hoa0217/study-repo/assets/48192141/987e8708-8f68-4ae9-8b4c-1d2db92dbc0f">

만약 응용 서비스에서 HttpSession을 변경해버리면? 표현 영역 코드만으로 표현 영역 상태가 어떻게 변경되는지 추적이 어려워진다.
- 즉, 표현 영역의 응집도가 깨지고 코드 유지보수 비용을 증가시킨다.

따라서 철저하게 응용 서비스가 표현 영역 기술을 사용하지 않도록 해야한다.
- 지키기 쉬운 방법은 서비스 메서드의 파라미터와 리턴타입으로 표현 영역의 구현기술을 사용하지 않는 것이다.

### 6.3.5 트랜잭션 처리
스프링과 같은 프레임워크가 제공하는 트랜잭션 관리 기능을 이용하면 쉽게 트랜잭션을 처리할 수 있다.
- 이를 통해 간단한 설정만으로 트랜잭션을 시작하여 커밋하고 익셉션이 발생하면 롤백할 수 있다.
- 스프링은 @Transactional이 적용된 메서드가 RuntimeException을 발생시키면 트랜잭션을 롤백하고 그렇지않으면 커밋한다.
- 이 규칙에 따라 코드를 작성하면 트랜잭션 처리 코드를 간결하게 유지할 수 있다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 21 42" src="https://github.com/hoa0217/study-repo/assets/48192141/5e7b3724-ed52-47ea-951d-927bf392c032">

## 6.4 표현 영역

표현영역의 책임은 아래와 같다.
- 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어한다.
- 사용자의 요청을 알맞은 응용서비스에 전달하고 결과를 사용자에게 제공한다.
- 사용자의 세션을 관리한다.

#### 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어한다.
- 웹 서비스의 표현 영역은 사용자가 요청한 내용으로 응답을 제공한다.
- 게시글 쓰기를 표현영역에 요청하면 아래와 같이 게시글을 작성할 수 있는 폼화면을 응답으로 제공한다.
- 그리고 사용자는 폼에 알맞은 값을 입려갛고 다시 표현 영역에 전송한다.
- 표현 영역은 응용 서비스를 이용해 요청을 처리하고 그 결과를 응답으로 전송한다.

<img width="400" alt="스크린샷 2024-05-19 오후 8 22 59" src="https://github.com/hoa0217/study-repo/assets/48192141/5c4c244a-dce9-4f51-b58b-2647e2ced2ec">

#### 사용자의 요청을 알맞은 응용서비스에 전달하고 결과를 사용자에게 제공한다.
- 화면을 보여주는데 필요한 데이터를 읽거나, 도메인 상태 변경 시 응용 서비스를 사용한다.
- 이 과정에서 사용자 요청 데이터를 응용서비스가 요구하는 형식으로 변환하고 응용 서비스 결과를 사용자에게 응답할 수 있는 형식으로 변환한다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 25 16" src="https://github.com/hoa0217/study-repo/assets/48192141/427d344a-238e-4148-931f-f64805b26928">

- MVC는 HTTP요청으로 부터 자바 객체를 생성하는 기능을 지원하므로 손쉽게 응용 서비스에 전달할 객체를 생성할 수 있다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 26 07" src="https://github.com/hoa0217/study-repo/assets/48192141/6e58cf74-5878-4e46-8b35-e22827495f8b">

- 응용서비스 실행 시 익셉션이 발생하면 에러 코드를 설정하는데, 표현 영역의 뷰는 이 에러코드에 알맞은 처리(메시지 출력 등)을 하게 된다.

#### 사용자의 세션을 관리한다.
- 웹은 쿠키나 서버 세션을 이용해서 사용자의 연결 상태를 관리한다.
- 세션 관리는 권한 검사와도 연결된다.

## 6.5 값 검증
값 검증은 표현 영여고가 응용 서비스 두곳에서 모두 수행할 수 있다.
- 원칙적으로 모든 값에 대한 검증은 응용서비스에서 처리한다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 30 54" src="https://github.com/hoa0217/study-repo/assets/48192141/5d56fa85-6c2f-46e3-9768-d2f8467213f0">

하지만, 표현 영역은 잘못된 값이 존재하면 이를 사용자에게 알려주고 다시 입력을 받아야한다.
- 만약 응용서비스에서 각 값이 유효현지 확인할 목적으로 익셉션을 사용하면 사용자에게 좋지 못한 경험을 제공한다.
- 폼에 값을 엽력하고 전송했는데, 값이 잘못되어 또 다시 입력하게 되면 불편할 것이다.
- 즉, 입력한 모든 항목에 대해 잘못된 값이 존재하는 지를 알고싶을 것이다.

따라서 이러한 불편을 해소하기 위해 응용 서비스 에러 코들르 모아 하나의 익셉션으로 발생시키는 방법도 있다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 33 42" src="https://github.com/hoa0217/study-repo/assets/48192141/b4c3d6bc-16cc-4056-a912-edfddbddae50">

그리고 표현 영역은 응용 서비스에서 위와같은 예외를 발생시키면 에러 목록을 가져와 표현 영역에서 사용할 형태로 변환한다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 34 46" src="https://github.com/hoa0217/study-repo/assets/48192141/9201ef41-273e-43cf-ae85-ed55af11d2ab">

<img width="500" alt="스크린샷 2024-05-19 오후 8 35 04" src="https://github.com/hoa0217/study-repo/assets/48192141/fdb058d3-c630-4cbb-bf3c-1f8edaf591f5">

또는 표현영역에서 필수값을 검증하는 방법도 있다.
- 특히 스프링은 Validator 인터페이스를 제공하므로 검증기를 따로 구현하면 간결히 작성 가능하다. 

<img width="500" alt="스크린샷 2024-05-19 오후 8 36 02" src="https://github.com/hoa0217/study-repo/assets/48192141/7d65f230-9949-4e12-bf21-084ac9d7456c">

이렇게 표현 영역에서 필수 값과 값의 형식을 검사하면, 실질적으로 응용서비스는 ID 중복 여부와 같은 논리적 오류만 검사하면 된다.

응용 서비스를 사용하는 표현 영역 코드가 한곳이라면 구현의 편리함을 위해 다음과 같이 역할을 나누어보자.
- 표현 영역: 필수 값, 값의 형식, 범위 등을 검증한다.
- 응용 서비스: 데이터의 존재 유무와 같은 논리적 오류를 검증한다.

> 얼마나 엄격하게 할지는 의견이 갈리지만, 저자는 가능하면 응용 서비스에서 필수값과 논리적 검증을 모두하는 편임.   
> 코드가 늘어나는 불편함이 있지만, 반대로 응용 서비스 완성도가 높아지는 이점이 있음.

## 6.6 권한 검사

개발하는 시스템 마다 권한의 복잡도가 다르다. 따라서 다양한 상황을 충족하기 위해 스프링 시큐리티 같은 프레임워크를 사용할 수 있다.
- 이는 유연한 만큼 복잡하다는 것을 의미하기도한다.
- 이런 보안 프레임워크에 대한 이애가 부족하면, 프레임워크를 무턱대고 도입하는 것보다 시스템에 맞는 권한 검사 기능을 구현하는 것이 유리할 수 잇다.

보안 프레임워크의 복잡도를 떠나 보통 3곳에서 권한검사를 수행한다.
- 표현 영역
- 응용 서비스
- 도메인

#### 표현 영역
기본적으로 인증된 사용자인지 아닌지 검사한다.

만약 회원정보 변경 URL은 인증된 사용자만 접근해야한다는 상황을 가정하고 구현한다면?
- URL을 처리하는 컨트롤러에 웹 요청을 전달하기 전, 인증 여부를 검사해 인증된 사용자의 웹 요청만 컨트롤러에 전달한다.
- 인증된 사용자가 아닐 경우 로그인 화면으로 리다이렉트 시킨다.

이러한 접근 제어를 하기 좋은곳은 **서블릿 필터**이다.
- 서블릿 필터에 사용자 인증 정보를 생성하고 인증 여부를 검사한다.
- 인증된 사용자면 다음 과정을 진행하고 그렇지 않으면 로그인 화면이나 에러 화면을 보여주면 된다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 42 48" src="https://github.com/hoa0217/study-repo/assets/48192141/076eab36-c2ab-4ef3-b005-3e8ef5c9381c">

> 인증 뿐 아니라 권한에 대해서도 동일한 방식으로 검사할 수 있다. 스프링 시큐리티는 이와 유사한 방식으로 필터를 이용하여 인증 정보 생성 및 웹 접근을 제어한다.

#### 응용 서비스
URL만으로 접근 제어를 할 수 없는 경우, 응용 서비스의 메서드 단위로 권한 검살르 수행해야한다.
- 꼭 응용 서비스 코드에서 권한 검사를 수행해야하는 것은 아니다.
- 예를 들면 스프링 시큐리티는 AOP를 활용해 다음과 같은 애너테이션으로 서비스 메서드 권한 검사를 수행한다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 44 50" src="https://github.com/hoa0217/study-repo/assets/48192141/6178406a-4283-4fa6-8892-4f704c0366e3">

#### 도메인
개별 도메인 객체 단위로 권한 검사를 해야하는 경우 구현이 복잡해진다.
- 게시글 삭제를 본인 또는 관리자만 할 수 있다면?
- 본인인지 확인하려면 게시글 애그리거트를 로딩해야한다.
- 그리고 다음과 같이 직접 권한 검사 로직을 구현해야한다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 45 44" src="https://github.com/hoa0217/study-repo/assets/48192141/14efee10-e66a-43c2-9d20-614aab31f92d">

스프링 시큐리티를 확장해서 개별 도메인 객체 수준의 권한 검사 기능을 프레임워크에 통합할 수 있다.
- 도메인 객체 수준의 권한 검사 로직은 도메인 별로 다르므로 도메인에 맞게 보안 프레임워크를 확장하려면 프레임 워크에 대한 높은 이해가 필요하다.
- 따라서 프레임워크를 사용하는 대신, 도메인에 맞는 권한 검사 기능을 직접 구현하는 것이 코드 유지보수에 유리하다.

## 6.7 조회 전용 기능과 응용 서비스

만약, 서비스에서 수행하는 추가적인 로직이 없고 단일 쿼리만 실행하는 조회 전용 기능이라 트랜잭션이 필요하지도 않다면?

굳이 서비스를 만들 필요없이 표현에서 바로 조회 전용 기능을 사용해도 문제가 없다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 48 45" src="https://github.com/hoa0217/study-repo/assets/48192141/c536f45c-5348-4db8-af33-bccbf6d78a23">

이상하게 느껴질 수 있지만, 응용 서비스가 사용자 요청을 실행하는데 별 기여를 하지 않는다면 굳이 서비스를 만들지 않아도 된다.

<img width="500" alt="스크린샷 2024-05-19 오후 8 49 50" src="https://github.com/hoa0217/study-repo/assets/48192141/7df14aea-62bb-4261-a6cb-85dc68bcdcec">

> 조회 전용 기능 (11장 CQRS)

