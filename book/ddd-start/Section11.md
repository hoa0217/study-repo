# Chapter11 CQRS
## 11.1 단일 모델의 단점

조회화면 특성상 조회 속도가 빠를 수록 좋은데 여러 애그리거트의 데이터가 필요하면 구현 방법을 고민해야한다.
- 만약 식별자를 이용해 애그리거트를 참조하는 방식(3장)은 즉시 로딩 방식과 같은 JPA의 쿼리 관련 최적화 기능을 사용할 수 없다.
- 이는 한번의 select문으로 필요한 데이터를 읽어올 수 없어 조회 성능에 문제가 생길 수 있다.

애그리거트 간 연관을 식별자가 아니라 직접 참조하는 방식으로 연결해도 고민이 생긴다.
- 조회 화면 특성에 따라 같은 연관도 즉시로딩 또는 지연로딩으로 처리해야하기 때문이다.
- 조회 기능 구현 시 DBMS가 제공하는 전용기능이 필요하면 JPA의 네이티브 쿼리를 사용해야할 수도있다.

이런 고민이 발생하는 이유는 시스템 상태를 변경하거나 조회할 때 단일 도메인 모델을 사용하기 때문이다.
- 객체 지향으로 도메인 모델을 구현할 때 주로 ORM기법은 도메인 상태 변경기능을 구현하는데는 적합하지만
- 주문 상테 조회 화면처럼 여러 애그리거트에서 데이터를 가져와 출력하는 기능을 구현하기에는 고려할게 많아 구현을 복잡하게 만든다.

구현 복잡도를 낮추는 방법은 바로 상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것이다.

참고: https://youtu.be/xf0kXMTFJm8?si=JPJtgnR1cKn_sFyp

## 11.2 CQRS

시스템이 제공하는 기능은 2가지로 나눌 수 있다.

1. 상태를 변경하는 기능
2. 사용자 입장에서 상태 정보를 조회하는 기능

- 도메인 모델 관점에서 상태 변경 기능은 주로 한 애그리거트의 상태를 변경한다.
- 주문 취소 기능과 배송지 정보 변경 기능은 주로 한 애그리거트의 상태를 변경한다.
- 반면 조회 기능은 데이터 표시를 위해 두 개 이상의 애그리거트가 필요할 때가 많다.

상태를 변경하는 범위와 상태를 조회하는 범위가 정확히 일치하지 않아 단일모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다.

이 복잡도를 해결하기 위해 CQRS를 사용한다.

#### CQRS(Command Query Responsibility Segregation)
상태를 변경하는 명령(Command)을 위한 모델과 상태를 제공하는 조회(Query)를 위한 보델을 분리하는 패턴이다.

<img width="500" alt="스크린샷 2024-06-02 오후 8 25 29" src="https://github.com/hoa0217/study-repo/assets/48192141/8350fbff-617c-4472-acae-63e458903e42">

CQRS는 복잡한 도메인에 적합하다.
- 도메인이 복잡할 수록 명령과 조회를 다루는 데이터 범위에 차이가 난다.
- 이를 단일 모델로 처리하면 조회 기능의 로딩 속도를 위해 모델 구현이 필요 이상으로 복잡해진다.
- 만약 통계를 조회해야한다고 하면, CQRS를 적용해 통계를 위한 조회 모델을 별도로 만들어 도메인 모델이 복잡해지는 것을 막을 수 있다.

CQRS를 사용하면 각 모델에 맞는 구현 기술을 선택할 수 있다.
- 명령 모델은 객체지향에 기반해서 JPA를 사용해서 구현하고 조회 모델은 SQL로 데이터를 조회할 때 좋은 마이바티스를 사용해서 구현하면 된다.

<img width="500" alt="스크린샷 2024-06-02 오후 8 27 53" src="https://github.com/hoa0217/study-repo/assets/48192141/25f3eb14-6a2d-4afc-beb0-3356d08fe922">

위 그림을 보면 조회 모델은 응용 서비스가 존재하지 않는다.
- 단순 데이터를 읽어와 조회하는 기능은 응용로직이 복잡하지 않기 때문에 컨트롤러에서 바로 DAO를 실행해도 무방한다.
- 물런 데이터를 표현 영역에 전달하는 과정에서 몇 로직이 필요하다면 응용 서비스를 두고 로직을 구현하면된다.

<img width="500" alt="스크린샷 2024-06-02 오후 8 28 56" src="https://github.com/hoa0217/study-repo/assets/48192141/4e228cd6-49ab-4761-b704-592cef96d27f">

위 그림은 명령 모델과 조회 모델의 설계 예를 보여준다.
- 상태 변경을 위한 명령 모델은 객체를 기반한 도메인 모델을 이용해서 구현한다.
- 반면 조회 모델은 주문 요약 목록을 제공할 때 필요한 정보를 담고있는 데이터 타입을 이용한다.
- 두 모델 모두 주문과 관련되어 있지만, 명령 모델은 상태를 변경하는 도메인 로직을 수행하는데 초첨을 맞춰 설계하고
- 조회 모델은 화면에 보여줄 데이터를 조회하는 데 초첨을 맞춰 설계했다.

명령 모델과 조회 모델은 같은 구현 기술을 사용할 수 있다.
- 5장: JPQL을 이용한 동적 인스턴스 생성과 하이버네이트 @Subselect를 이용할 수 있다.
- 여기서 동적인스턴스와 @Subselect를 적용한 클래스가 조회 모델이다.

<img width="500" alt="스크린샷 2024-06-02 오후 8 31 16" src="https://github.com/hoa0217/study-repo/assets/48192141/7be9578a-4e9e-406e-b9ee-9a6425939321">

명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 수도 있다.
- 명령 모델은 트랜잭션을 지원하는 RDBMS를 사용하고 조회 모델은 조회 성능이 좋은 메모리 기반 NoSQL을 사용할 수도 있다.
- 두 저장소간 데이터 동기화는 10장에 나온 이벤트를 활용해서 처리한ㅏ.
- 명령 모델에서 상태를 변경하면 이에 해당하는 이벤트가 발생하고, 그 이벤트를 조회 모델에 전달하여 변경 내역을 반영하면 된다.

두 모델이 서로 다른 데이터 저장소를 사용하면, 데이터 동기화 시점에 따라 구현방식이 달라질 수 있다.

명령 모델에서 데이터가 바뀌자마다 변경 내역을 바로 조회 모델에 반영해야한다면?
- 동기 이벤트와 글로벌 트랜잭션을 사용해서 실시간으로 동기화 할 수 있다.
- 하지만 이는 전반적인 성능(응답 속도와 처리량)이 떨어지는 단점이 있다.

서로 다른 저장소의 데이터를 특정시간 안에만 동기화해도 된다면?
- 비동기로 데이터를 전송하면된다.
- 만약 통계 처리목적으로 조회 전용 저장소를 구축했다면
- 통계 데이터는 수초, 수분, 또는 1시간 단위로 최근 데이터를 반영해도 문제가 되지 않을 때가 많다.
- 이럴 경우 비동기로 데이터를 보맨으로써 데이터 동기화로 인해 명령 모델의 성능이 나빠지지 않도록 할 수 있다.

> CQRS 패턴을 적용하기 위해 사용해야할 필수기술이 따로 존재하는 것은 아님. JPA만 사용해서 명령/조회 모델을 구현할 수 있음.

### 11.2.1 웹과 CQRS
일반적인 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 많다.
- 온라인 쇼핑몰을 보면 주문 요청보다 카탈로그 조회 및 상세 정보를 조회하는 요청이 훨씬 많다.

포털/온라인쇼핑몰 같이 조회 기능 요청이 월등히 높은 서비스를 만드는 개발팀은 조회 성능을 높이기 위해 다양한 기법을 사용한다.
- 기본적으로 쿼리를 최적화해서 쿼리 실행 속도 자체를 높이고, 메모리에 조회 데이터를 캐싱해서 응답 속도를 높인다.
- 또는 조회 전용 저장소를 따로 사용하기도 한다.

이렇게 다양한 기법을 사용하는 것은 결과적으로 CQRS를 적용하는 것과 같은 효과를 만든다.
- 메모리에 캐싱하는 데이터는 DB에 보관된 데이터를 그대로 저장하기 보단, 화면에 맞는 모양으로 변환한 데이터를 캐싱할 때 성능이 유리해진다.
- 즉 조회 전용 모델을 캐시하는 것이다.
- 비슷하게 조회 속도를 높이기위해 쿼리를 최적화한다는 것은, 조회 화면에 보여줄 데이터를 빠르게 읽어올 수 있도록 쿼리를 작성하는 것이다.

즉, 조회 속도를 높이기 위해 별도 처리를 하고 있다면 이는 명시적으로 명령/조회 모델을 구분하자.
- 이를 통해 조회 기능때문에 명령 모델이 복잡해지는 것을 막을 수 있고
- 명령 모델에 관계없이 조회 기능에 특화된 구현기법을 쉽게 적용할 수 있다.

#### 11.2.2 CQRS 장단점

#### 장점

명령 모델 구현 시 도메인 자체에 집중할 수 있다.
- 복잡한 도메인은 주로 상태 변경 로직이 복잡한데, 명령/조회 모델을 구분하면 조회 성능을 위한 코드가 명령 모델에 없으므로 도메인 로직을 구현하는데 집중할 수 있다.
- 또한 명령 모델에서 조회 관련 로직이 사라져 복잡도가 낮아진다.

조회 성능을 향상시키는데 유리하다.
- 조회 단위로 캐시 기술을 적용할 수 있고, 조회에 특화된 쿼리를 마음대로 사용할 수 있다.
- 캐시 뿐 아니라 조회 전용 저장소를 사용하면, 조회 처리량을 대폭 늘릴 수 있다.
- 조회 전용 모델을 사용하기 때문에 조회 성능을 높이기 위한 코드가 명령 모델에 영향을 주지 않는다.

<img width="400" alt="스크린샷 2024-06-02 오후 8 40 45" src="https://github.com/hoa0217/study-repo/assets/48192141/e0e93913-11c1-4df7-b3fb-5e98fb004023">

#### 단점
구현해야할 코드가 더 많아진다.
- 단일 모델을 사용할 때 발생하는 복잡함 때문에 발생하는 구현 비용과 조회 전용 모델을 만들 때 발생하는 구현 비용을 따져봐야 한다.
- 도메인이 복잡하거나 대규모 트래픽이 발생하는 서비스라면 조회 전용 모델을 만드는 것이 향후 유지 보수에 유리하다.
- 반면 도메인이 단순하거나 트래픽이 많지 않은 서비스라면 조회 전용 모델을 따로 만을 때 얻을 이점이 있는지 따져봐야한다.

더 많은 구현 기술이 필요하다는 것이다.
- 명령 모델과 조회 모델을 다른 구현기술을 사용해서 구현하기도 하고 경우에 따라 다른 저장소를 사요하기도 한다.
- 또한 데이터 동기화를 위해 메시징 시스템을 도입할 수 있다.

따라서 위 장단점을 고려해 CQRS패턴을 도입할지 여부를 결정해야한다.
- 도메인이 복잡하지 않다면 CQRS를 도힙하는데 유지하는 비용만 높아지고 얻을 수 있는 이점은 없다.
- 반면 트래픽이 높은 서비스인데 단일모델을 고집하면 유지 보수 비용이 높아질 수 있으므로 CQRS 도입을 고려하자.

