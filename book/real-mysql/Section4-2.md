# 4.2 InnoDB 스토리지 엔진 아키텍처

<img width="550" alt="스크린샷 2024-04-18 오후 9 06 09" src="https://github.com/hoa0217/study-repo/assets/48192141/77f4d411-db3f-41e7-a73b-d76ea3ce0bcb">

- InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 유일하게 레코드 기반 잠금을 제공한다.
- 이를 통해 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

## 4.2.1 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 프라이머리 키를 기준으로 클러스터링되어 저장된다.
- 즉, 프라이머리 키 값의 순서대로 디스크에 저장된다.
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 **논리적인 주소**로 사용한다.
- 프라이머리 키가 **클러스터링 인덱스**이기 때문에, 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.
- 결과적으로 쿼리 실행 계획에서 다른 보조 인덱스에 비해 비중이 높게 설정된다. (실행 계획에서 선택될 확률이 높다) ➡️ 8.8장에서 자세히 다룸

MyISAM 스토리지 엔진은 클러스터링 키를 지원하지않는다.
- MyISAM 테이블에서 프러이머리 키와 세컨더리 인덱스는 구조적으로 차이가 없다.
- 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스일 뿐이다.
- MyISAM 테이블의 프라이머리 키를 포함하는 모든 인덱스는 물리적인 주소값(ROWID)를 갖는다. ➡️ 4.3.3에서 자세히 다룸

## 4.2.2 외래 키 지원
외래 키는 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM, MEMORY 테이블에서는 사용할 수 없다.
- 외래 키는 서버 운영의 불편함으로 생성하지 않는 경우도 있지만 개발 환경에서는 좋은 가이드 역할을 한다.
- InnoDB에서 외래키는 부모와 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고
- 변경 시 반드시 부모나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하다.
- 그로 인해 데드락이 발생할 때가 많으므로 개발 시 외래키 존재에 주의하자.

외래키가 복잡하게 얽힌경우 수동 데이터 생성/스키마 변경 등의 작업이 실패할 수 있다.
- 긴급하게 뭔가 조치를 해야하는데 문제가 발생한 경우 `foreign_key_checks` 시스템 변수를 OFF로 설정하면 외래 키 관계에 대한 체크작업을 일시적으로 멈출 수 있다.
- 멈추면 레코드 적재나 삭제 등의 작업도 부가적인 체크가 필요없기 때문에 빠르게 처리할 수 있다.

```sql
mysql> SET foreign_key_checks=OFF;
// 작업실행
mysql> SET foreign_key_checks=ON;
```
> 이는 GLOBAL, SESSION 모두 설정가능한 변수이다. 이런 작업을 수행할 땐 현재 세션에만 적용해야하므로 SESSION키워드를 명시하던지 아니면 아무것도 명시하지 않아야한다.
> 작업이 완료되면 반드시 현재 세션을 종료하거나, 외래키 체크를 활성화하자.

하지만 일시적으로 해제했다고 해서 부모-자식 관계가 깨진 상태로 유지해도되는 건 아니다.
- 만약 외래키 체크를 중지한 상태에서 외래키 관계를 가진 부모 레코드를 삭제했다면, 자식 레코드도 삭제해야한다.
- 그리고 일관성을 맞춰준 후 다시 외래키 체크 기능을 활성화해야한다.
> 만약 외래키 체크가 중지되었다면 `ON DELETE CASCADE`, `ON UPDATE CASCADE` 옵션은 무시된다.
> 이는 자동으로 자식 테이블에 매치되는 row에도 똑같이 DELETE, UPDATE를 반영하는 것을 의미한다.

### 4.2.3 MVCC(Multi Version Concurrency Control)
레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 **잠금을 사용하지 않는 일관된 읽기**를 제공하는 데 있다.
- InnoDB는 **Undo log**를 이용해 이 기능을 구현한다.
- 여기서 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미이다.

#### Isolation level에 따른 데이터 조회 예시

1. 테이블을 생성한다.
```sql
mysql> CREATE TABLE member (
    m_id INT NOT NULL,
    m_name VARCHAR(20) NOT NULL,
    m_area VARCHAR(100) NOT NULL,
    PRIMARY KEY (m_id),
    INDEX ix_area (m_area)
    );
```

2. 레코드 한건을 INSERT한다.
```sql
mysql> INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
mysql> COMMIT;
```

<img width="500" alt="스크린샷 2024-04-18 오후 9 48 48" src="https://github.com/hoa0217/study-repo/assets/48192141/6542d753-cfb7-4136-bf81-29b68789ee20">

3. 해당 레코드를 업데이트 한다.
```sql
mysql> UPDATE member SET m_area = '경기' where m_id = 12;
```

<img width="500" alt="스크린샷 2024-04-18 오후 9 50 30" src="https://github.com/hoa0217/study-repo/assets/48192141/5badc2e5-00fb-41a0-a578-00e689e5dfbd">

update 쿼리가 실행되면 커밋 실행 여부와 관계 없이 **InnoDB 버퍼풀**은 새로운 값으로 업데이트 된다.

그리고 **데이터 파일**(디스크)는 체크포인트나 InnoDB의 Write 스레드에 의해 업데이트돼있을 수 도 있고 아닐 수 도 있다.
- InnoDB가 ACID를 보장하기 때문에 일반적으로 InnoDB의 버퍼풀과 데이터파일은 동일한 상태라고 가정해도 무방하다.

아직 COMMIT이나 ROLLBACK을 하지 않은 상태에서 다른 사용자가 조회하면 어디 데이터를 조회할까?
```sql
SELECT * FROM member where m_id = 12;
```
- 이는 시스템변수(transaction_isolation)에 설정된 Isolation level(격리수준)에 따라 다르다.
- `READ_UNCOMMITTED`: 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.
- `READ_COMMITTED` or 그 이상의 격리: 아직 커밋이 되지 않았기 때문에 버퍼 풀이나 데이터 파일 대신 변경되기 이전의 내용을 보관하고 있는 **언두 영역의 데이터를 반환한다.**
  - 그 이상의 격리: `REPEATABLE_READ`, `SERIALIZABLE`
 
#### 그래서 MVCC란
이러한 과정을 DBMS에서는 MVCC라고 표현한다. 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 상황에 따라 달라지는 구조다.
- 여기서는 한개의 데이터만가지고 설명했지만, 예전 버전의 데이터는 무한히 많아질 수 있다.
- 만약 트랜잭션이 길어지면 언두에서 관리하는 예전 데이터는 삭제되지 못하고 오래 관리돼야한다.
- 자연히 언두 영역이 시스템 테이블스페이스의 공간을 많이 차지하게된다.

#### COMMIT & ROLLBACK
위 상태에서 커밋을 실행하면, InnoDB는 더이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버린다.

하지만 롤백을 실행하면 InnoDB는 언두 영역에 있는 데이터를 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제한다.

> 커밋을 한다고해서 언두 영역의 데이터가 바로 삭제되는 것은 아니며, 언두 영역을 필요로 하는 트랜잭션이 없을 때 삭제된다.

## 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
MVCC 기술을 통해, 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 작업을 수행한다.
- `SERIALIZABLE`를 제외한 `READ_UNCOMMITTED`, `READ_COMMITTED`, `REPEATABLE_READ`격리 수준에서 순수한 읽기(SELECT)는 다른 트랜잭션의 변경 작업과 관계없이 잠금을 대기하지 않고 바로 실행한다.

<img width="400" alt="스크린샷 2024-04-18 오후 10 10 43" src="https://github.com/hoa0217/study-repo/assets/48192141/3e8506b1-0ba1-4d8b-a552-ed6a3a43769c">

> 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않는다. ➡️ 잠금 없는 일관된 읽기

- 오랜 시간 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 있는데
- 이런 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제다.
- 따라서 트랜잭션이 시작됐다면 가능한 빨리 롤백/커밋으로 트랜잭션을 완료하는 것이 좋다.

## 4.2.5 자동 데드락 감지
InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List)형태로 관리한다.
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 **교착 상태인 트랜잭션들을 찾아 하나를 강제 종료한다.**
- 강제 종료 기준은 트랜잭션의 언두 로그 양이며, **언두 로그를 적게 가진 트랜잭션이 롤백의 대상이 된다.**
- 적게 가졌다는 이야기는? 롤백 해도 언두 처리해야할 내용이 적다는 것, 강제 롤백으로 인한 서버 부하도 적다는 것.

> 참고로 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금(Lock Tables 명령으로 잠긴 테이블)은 볼 수 없어서 데드락 감지가 불확실할 수 도 있다.   
> 이때 `innodb_table_locks` 시스템 변수를 활성화하면 레코드 잠금뿐 아니라 테이블 잠금까지 감지할 수 있다.

일반적으로 **데드락 감지 스레드**의 작업은 크게 부담되지않지만, 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 느려진다.
- 데드락 감지 스레드는 잠금 목록을 검사해야 하기 때문에 잠금 상태가 변경되지 않도록 **잠금 목록이 저장된 잠금 테이블**에 새로은 잠금을 걸고 데드락 스레드를 찾는다.
- 데드락 감지 스레드가 느려지면, 서비스 요청을 수행중인 스레드는 더 이상 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 준다.
- 따라서 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수 있다.

이런 상황에선 `innodb_deadlock_detect`를 OFF로 설정하여 데드락 감지 스레드의 작동을 멈춘다.
- 데드락 상황이 발생하게 된다면 무한정 대기하게 되겠지만, `innodb_lock_wait_timeout`를 활성화하면 일정시간이 지난 후 자동으로 요청이 실패하고 에러를 반환한다.
- `innodb_lock_wait_timeout`는 초단위로 설정 가능하며, 잠금을 설정 시간동안 획득하지 못하면 쿼리는 실패한다.
- `innodb_deadlock_detect`를 비활성화하는 경우라면 `innodb_lock_wait_timeout`을 default 값인 50초보다 낮은 시간으로 변경해서 사용할 것을 권장한다.

> 만약 PK 또는 세컨더리 인덱스를 기반으로 매우 높은 동시성 처리를 요구하는 서비스가 있다면 `innodb_deadlock_detect`를 비활성화해 성능을 비교해보자.

