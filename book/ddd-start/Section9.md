# Chapter9 도메인 모델과 바운디드 컨텍스트
## 9.1 도메인 모델과 경계

처음 도메인 모델을 만들 때 빠지기 쉬운 함정은 도메인을 완벽히 표현하는 단일 모델을 만드는 시도를 하는 것이다.
- 하지만 한 도메인은 다시 여러 하위 도메인으로 구분되기 때문에, 한 개의 모델로 모두 표현하려고 시도하면 오히려 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.

상품이라는 모델을 생각했을 때 `카탈로그`에서 상품, `재고 관리`에서 상품, `주문`에서 상품, `배송`에서 상품은 이름만 같지 실제 의미하는 것이 다르다.
- `카탈로그`에서 상품: 상품이미지, 상품명, 상품가격, 옵션목록, 상세 설명 ➡️ **상품 정보 위주**
- `재고 관리`에서 상품: 실존하는 **개별 객체를 추적**하기위한 목적

> 즉, 카탈로그에서는 물리적으로 한 개인 상품이 재고 관리에서는 여러개 존재할 수 있다.

논리적으로 같은 존재처럼 보이지만, 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다.
- 회원 도메인에서는 회원이지만, 주문 도메인에서는 주문자, 배송 도메인에서는 보내는 사람이라고 부른다.

<img width="400" alt="스크린샷 2024-05-28 오후 5 40 18" src="https://github.com/hoa0217/study-repo/assets/48192141/c2cea697-e344-41d2-b3af-65730770e849">

이렇게 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기에, 한 개의 모델로 모든 하위도메인을 표현하려는 시도는 올바른 방법이 아니다.

따라서 올바른 도메인 모델을 개발하려면, 하위 도메인마다 모델을 만들어야한다.
- 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야한다.
- 여러 하위 도메인의 모델이 섞이기 시작하면 모델의 의미가 약해질 뿐 아니라 여러 도메인의 모델이 서로 얽히기 때문에
- 하위 도메인별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워진다.

모델은 특정한 컨텍스트(문맥)하에 완전한 의미를 갖는다.
- 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 바운디드 컨텍스트(Bounded Context)라고 부른다.

## 9.2 바운디드 컨텍스트
바운디드 컨텍스트: 모델의 경계를 결정하며, 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.

이는 용어를 기준으로 구분한다.
- 카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 컨텍스트를 분리할 수 있다.
- 또한 실제로 사용자에게 기능을 제공하는 물리적 시스템으로 도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현한다.

이상적으로 하위 도메인과 바운디드 컨텍스트가 일대일관계를 가지면 좋겠지만, 팀의 조직 구조에 따라 결정되기도 한다.
- 예시로 주문 하위도메인이라도 주문을 처리하는 팀과 복잡한 결제 금액 계산 로직을 구현하는 팀이 따로 있다면?
- 이 경우 주문 하위도메인에 주문 바운디드 컨텍스트와 결제 금액 계산 바운디드 컨텍스트가 존재하게 된다.
- 그리고 카탈로그와 재고관리가 명확하게 구분되지 않은 경우 두 하위 도메인을 하나의 바운디드 컨텍스트에서 구현하기도한다.

<img width="500" alt="스크린샷 2024-05-28 오후 5 47 24" src="https://github.com/hoa0217/study-repo/assets/48192141/1d0a5ea0-d3b4-4d00-9392-c01b1ac13805">

규모가 작은 기업은 전체 시스템을 한 개 팀에서 구현할 때도 있다.
- 소규모 쇼핑몰은 한 어플리케이션에서 서비스를 하기에 한 시스템에서 회원, 카탈로그, 재고, 구매, 결제와 관련된 모든 기능을 제공한다.
- 즉, 여러 하위 도메인을 한개의 바운디드 컨텍스트에서 구현한다.

이 경우 주의할 점은 **하위 도메인의 모델이 섞이지 않도록 해야한다.**
- 한 프로젝트에 각 하위 도메인의 모델이 위치하면, 전체 하위 도메인을 위한 단일 모델을 만들고 싶은 유혹에 빠지기 쉽다.
- 이런 유혹에 걸려들면 결과적으로 도메인 모델이 개별 하위 도메인을 제대로 반영하지 못하여 하위 도메인 별 기능을 확장하기 어렵게 된다.

비록 한개의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 갖도록 구현해야한다.
- 이렇게 함으로써 하위 도메인을 위한 모델이 서로 뒤섞이지 않고 하위 모데인마다 바운디드 컨텍스트를 갖는 효과를 낼 수 있다.

<img width="500" alt="스크린샷 2024-05-28 오후 5 53 56" src="https://github.com/hoa0217/study-repo/assets/48192141/ca4887ef-f306-450b-9f43-7636f83f99c2">

바운디드 컨텍스트는 구현하는 하위 모데인에 알맞는 모델을 포함한다.
- 같은 사용자여도 회원 바운디드 컨텍스트에서는 Memeber가 애그리거트 루트이지만, 주문 바운디드 컨텍스트에서는 Orderer가 밸류가 된다.
- 같은 상품이라도 카탈로그 바운디드 컨텍스트의 Product는 Category와 연관을 갖지만, 재고 바운디드 컨텍스트의 Product는 카탈로그의 Category와 연관을 맺지 않는다.

<img width="500" alt="스크린샷 2024-05-28 오후 5 58 40" src="https://github.com/hoa0217/study-repo/assets/48192141/eb2075e8-af7c-46a7-808a-4888bfe30c36">

## 9.3 바운디드 컨텍스트 구현

바운디드 컨텍스는 도메인 기능을 사용자에게 제공하는데 필요한 표현영역, 응용서비스, 인프라스트럭처 영역을 모두 포함한다.
- 도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야하므로 테이블도 포함된다.

<img width="400" alt="스크린샷 2024-05-28 오후 6 00 47" src="https://github.com/hoa0217/study-repo/assets/48192141/2b2c1922-b768-44f1-805c-1c020614d6ad">

> 표현 영역은 사용자를 위해 HTML 페이지를 생성할 수도 있고, 다른 바운디드 컨텍스트를 위해 REST API를 제공할 수 도 있다.

모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.
- 상품 리뷰는 복잡한 도메인 로직이 없기 때문에 CRUD 방식 구현해도 된다.
- DAO-데이터 중심의 밸류 객체를 이용해서 리뷰 기능을 구현해도 유지 보수에 문제가 없다.
- 물론 서비스-DAO 구조를 사용하면 도메인 기능이 서비스에 흩어지게되지만, 도메인 기능이 단순하면 유지 보수에 문제가 없다.
<img width="500" alt="스크린샷 2024-05-28 오후 6 03 49" src="https://github.com/hoa0217/study-repo/assets/48192141/7e2599d1-d6e7-4570-aa54-66ff90553fa0">

한 바운디드 컨텍스트에서 두 방식을 혼합해서 사용할 수 있다.
- 대표적인 예가 CQRS(Command Query Responsibility Segregation) 패턴이다.
- 이는 상태를 변경하는 명령 기능과 내용을 조회하는 쿼리 기능을 위한 모델을 구분하는 패턴이다.
- 이를 단일 바운디드 컨텍스트에 적용하면, 상태 변경과 관련된 기능은 도메인 모델 기반으로 구현하고 조회 기능은 서비스-DAO를 이용해서 구현할 수 있다.

<img width="500" alt="스크린샷 2024-05-28 오후 6 12 40" src="https://github.com/hoa0217/study-repo/assets/48192141/00fcf556-5337-400f-ba06-4e987d65b17f">

각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수 있다.
- 스프링MVC + JPA/하이버네티트를 사용하는 바운디드 컨텍스트가 존재할 수 있고, Netty + Mybatis를 사용하는 바운디드 컨텍스트가 존재할 수 있다.
- 어떤 바운디드 컨텍스트는 RDBMS 대신, 몽고DB같은 NoSQL을 사용할 수도 있다.

바운디드 컨텍스트는 반드시 사용자에게 보여지는 UI를 가지고 있어야 하는 것은 아니다.
- 카탈로그 바운디드 컨텍스트를 통해 상세정보를 읽어온뒤, 리뷰 바운디드 컨텍스트의 API호출 해 로딩한 JSON 데이터를 알맞게 가공하여 리뷰목록을 보여줄 수 있다.

<img width="500" alt="스크린샷 2024-05-28 오후 6 16 32" src="https://github.com/hoa0217/study-repo/assets/48192141/38f166d2-f7df-4759-acac-5ce931773c86">

또는 UI 서버를 두고, UI 서버에서 바운디드 컨텍스트와 통신해 사용사 요청을 처리하는 방법도 있다.
- 여기서 UI서버는 각 바둔디드 컨텍스트를 위한 퍼사드 역할을 수행한다.
- 브라우저가 UI서버에 요청을 보내면 UI서버는 카탈로그와 리뷰 바운디드 컨텍스트로부터 필요한 정보를 읽어와 조합한 뒤 브라우저데 응답을 제공한다.

<img width="500" alt="스크린샷 2024-05-28 오후 6 18 20" src="https://github.com/hoa0217/study-repo/assets/48192141/acf1ea6f-3e63-4c85-a594-da996be7fe3a">



