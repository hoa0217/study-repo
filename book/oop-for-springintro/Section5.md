## 객체 지향 설계 5원칙 - SOLID

### SOLID

- 객체지향언어를 이용해 객체지향 프로그램을 올바르게 설계해나가는 방법과 원칙
- **응집도**를 높이고 **결합도**는 낮추라는 원칙을 객체 지향 관점에서 정립한 것

> **결합도** : **클래스간 상호 의존** 정도 ➡️ 클래스간 의존성이 줄어들면 객체의 **재사용, 유지보수**가 용이하다.
 
> **응집도** : **하나의 클래스 내부에 존재하는 구성 요소들의 기능적 관련성** ➡️ 하나의 책임에 집중하고 독립성이 높아지면 **재사용, 유지보수**가 용이하다.
> 

### SRP(단일책임원칙)

```
**어떤 클래스를 변경해야하는 이유는 오직 하나뿐이어야 한다.**
```

- 클래스가  SRP를 지키지 못하는 경우
    - 만약 **사람**이라는 클래스를 의존하는 다양한 클래스(반려동물, 부모님, 사수)가 있다면?
        - 사람이라는 클래스는 역할과 책임이 많기 때문에 **신경써야 할 부분이 너무 많다.**
    - 이런 경우 역할(책임)을 분리하는 것이 단일 책임 원칙이다.
        - 집사, 자식, 사원으로 클래스를 분리하자.
- 속성이 SRP를 지키지 못하는 경우
    - 사람이라는 클래스에 사번이라는 속성이있다. 하지만 사번은 **회사원**에게만 필요할 뿐 **학생**에게 필요가 없다.
    - 회사원과 학생이 공통점이 없다면 사람클래스를 제거하여 회사원클래스, 학생클래스를 따로 만들고
    - 공통점이 많다면 사람클래스 상위클래스에 두고 상속 후 각자 차이점만 구현하면된다.
    
    > **하나의 속성이 여러의미를 갖는 것**도 단일책임 원칙을 지키지 못하는 것   
    > - 번호라는 필드를 학생은 학번, 회사원을 사번이라고 쓰는 경우 여기저기 **if**문을 사용해야한다.
     
- 메서드가 SRP를 지키지 못하는 경우
    - 급여계산 시 회사마다 산정방식이 다른데 이걸 절차지향적으로 작성하면, 분기 처리를 위한 if문이 등장한다.
    - 단일 책임을 적용해 리팩토링 한다면?
        - 공통 계산 클래스를 상위 클래스에 두고, 상속 후 각 회사 별로 계산하는 메서드를 구현한다.
- 따라서 이 단일책임원칙은 클래스 설계하는 추상화 과정에서 가장 중요하다.
    - 추상화를 통해 클래스를 선별 하고, 속성과 메서드를 설계할 때 단일 책임 원칙을 고려해야한다.
- 만약 지키지 못한다면?
    - 여러개의 역할을 가지게 되기 때문에 수정이 무척 힘들어질 것. (유지보수가 너무 좋지않음)

### OCP(개방폐쇄원칙)

```
소프트웨어는 확장에 대해서 열려있어야하지만 변경에 대해서는 닫혀있어야한다.
- **자신의 확장에는 열려있고 주변의 변화에 대해서는 닫혀 있어야 한다.**
```

- 개방폐쇄원칙을 지키지 못한다면?
    - 키보드라는 클래스가있다. 사용자가 A사의 키보드를 사용하다 B사의 키보드를 구매했다.
        - 한영을 바꿀 때 A사는 한/영키를 사용하지만 B사는 capslock키를 사용한다.
        - 키보드를 바꿈으로 써 **사용자가 영향을 받는다.**
- 하지만 만약 키보드라는 인터페이스를 중간에 두게 된다면 현실세계에선 영향을 받겠지만, 객체지향에서는 영향을 받지 않는다.
    - **한/영바꾸기**라는 메서드를 이전과 똑같이 호출하면 될 뿐 내부구현은 신경쓰지 않아도 된다.
        - 개방폐쇄원칙을 지키는것
    - 즉, 키보드 입장에서는 확장에 개방되어있고 사용자는 주변 변화에 폐쇄되어있다.
- 실제 예) JDBC
    - 자바 어플리케이션에서는 JDBC인터페이스를 사용함으로써, DB가 오라클에서 MySQL로 바뀌어도 Connection을 설정하는 부분외에 따로 수정할 필요가 없다.
    - 즉, DB 입장에서는 확장에 개방되어있고 자바어플리케이션은 주변 변화에 폐쇄되어있다.
- 개방 폐쇄 원칙을 지키게된다면?
    - **유연성, 재사용성, 유지보수성**을 얻을 수있다.

### LSP(리스코프 치환원칙)

```
**서브 타입은 언제나 나신의 기반 타입(base type)으로 교체할 수 있어야한다.**
- 하위 클래스의 인스턴스는 상위형 객체 참조변수에 대입하여 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야한다.
```

- 하위클래스 is a kind of 상위클래스
    - 아버지 - 딸 ⇒ 위배, 동물 - 펭귄 ⇒ 만족
- 지킴으로써 장점은?
    - 상위클래스의 메서드를 재사용할 수 있다.
    - 상위클래스의 특성을 확장할 수 있다.
        - 추가로 메서드를 작성도 할 수 있고 오버라이딩 통해 재정의하여 사용할 수 있다.
    - 하위클래스는 상위클래스를 대신할 수 있으며 이를 통해 **다형성**을 사용할 수 있다.

### ISP(인터페이스 분리원칙)

```
**클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다**
```

- 사람이라는 클래스를 단일책임원칙을 지키기위해 자식, 집사, 사원으로 토막냈었다.
- 하지만 인터페이스로도 분할할 수 있는 방법이 있다.
    - 같은 문제에 대한 두가지 다른 해결책
- 인터페이스로 분리할 경우에는 외부에 최소한의 메서드만 제공하는 것이 좋다.
    - 만약 사용하지 않는 메서드도 인터페이스를 통해 제공한다면, 강제로 구현해야하기 때문이다,

> 결론 : 상위클래스는 풍성할 수록 좋고 인터페이스는 작을 수록 좋다.
만약 상위클래스가 빈약하다면 형변환이 빈번하게 일어나기 때문에 다형성의 혜택을 누릴 수 없다.
> 

### DIP(의존 역전 원칙)

```
고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈은 모두 다른 추상화된 것에 의존해야한다.
추상화된 것은 구체적인 것에 의존하면안된다. 구체적인것이 추상화 된것에 의존해야한다.
```

- 의존 역전 원칙을 지키지 않는다면?
    - 아까 개방폐쇄원칙을 설명할 때 JDBC 템플릿 인터페이스를 통해 DB가 변경되어도 자바어플리케이션에는 영향을 미치지 않는다고 하였다.
    - 만약 구체화된 오라클의 JDBC드라이버를 의존한다면, MySQL로 변경하게 될 때 코드를 전부 뜯어 고쳐야한다.
- 만약 고차원 모듈이 저차원 모듈을 의존하는 경우 추상화된 인터페이스나 상위클래스를 중간에 둔다면?
    - 의존의 방향을 추상화쪽으로 뒤집을 수 있다.
    - 만약 추상적인 것에 의존하게 된다면 변하기 쉬운 것의 영향을 받지 않게 된다.
    - 자동차(고차원) → 스노우 타이어(저차원) ⇒ 자동차(고차원) → 타이어(추상화된것) ← 스노우타이어(저차원)
    - 사용자 → A사키보드 ⇒ 사용자 → 키보드 ← A사 키보드
    - 자바 어플리케이션 → MySQL 드라이버 ⇒ 자바 어플리케이션 → JDBC 템플릿 ← MySQL 드라이버

> 자신보다 변하기 쉬운것에 의존하면 안된다.
> 

> 상위클래스일수록, 인터페이스일수록, 추상화클래스일수록 변하지 않을 가능성이 높기때문에   
하위클래스나 구체클래스가 아닌 상위클래스, 인터페이스, 추상화클래스에 의존하라는 것이 의존역전원칙.
>