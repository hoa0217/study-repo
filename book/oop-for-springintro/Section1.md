## 1. 사람을 사랑한 기술
### 신기술은 이전 기술의 어깨를 딛고

- 스프링을 비롯한 모든 신기술은 이전 기술의 철학과 기법을 정제하고 더해 나타나는 것이다.
- 스프링 이전에는 어떤 기술을 이해하고 있어야할까?
  - SOA
  - CBD
  - OOP
  - 절차적/구조적 프로그래밍
  - **기계어와 어셈블리** (모범답안)
> 이전 기술을 마스터 할 필요는 없다. 빠르게 돌아보자.

<hr/>

### 기계어에서 객체 지향 프로그래밍 언어로

#### 기계어 - 0과 1의 행진 / 너무나 비인간적인 언어

- 컴퓨터는 0과 1밖에 이해하지 못하지만 대단히 **빠르고 성실하며 정확하다.**
- 인류 최초의 프로그래머들은 0과 1로 해석할 수 있는 백열전구를 이용해 프로그램을 작성했다.
- 기계어 : 기계가 이해하는 유일한 언어로, 2진 숫자인 0과 1로만 표현된다.
  - 기계어 코드는 CPU에 따라 다르다. 
  - 즉, 기종간 호환이 불가능하다.
    
```
01010101 00000001 00001001
```

> 1+3을 수행하는 애드삭(EDSAC) 기계어 프로그래밍 코드

```
11011100 00011000 10011000
```

> 1+3을 수행하는 유니박(UNIVAC) 기계어 프로그래밍 코드

#### 어셈블리어 - 0과 1의 행진을 벗어나 인간 지향으로 / 기계어 니모닉

- 기계어는 컴퓨터가 이해하는 유일한 언어지만 인간이 눈높이에는 수준이 너무 낮다.
- 어느날 한 천재가 아래와 같은 생각으로 **니모닉(Mnemonic)** 과 **기계어** 1대1 매칭 **코드표**를 만들었다.
  > 기계어 명령어를 일상용어로 표현하고 이걸 기계가 알 수 있는 기계어로 번역하게 하면 어떨까?
  - 이 코드표가 **어셈블리**이다.
- 하지만 CPU별로 기계어가 다르기 때문에 **어셈블리어(Assembly Language)** 도 달랐다.
  - 어셈블러(Assembler) : 어셈블리어를 기계어로 번역해주는러 SW 
  - 애드삭 : 더하기를 의미하는 `01010101` ➡️ 니모닉으로 **ADD**
  - 유니박 : 더하기를 의미하는 `11011100` ➡️ 니모닉으로 **PLUS**
- 결론 : **어셈블리어**를 통해 기계어를 벗어나 **인간의 언어**를 모방해 프로그램 작성이 가능해졌다.
  - 하지만 애드삭 어셈블리어로 유니박을 실행할 수는 없다.

#### C언어 - 강력한 이식성 / One Source Multi Object Use Anywhere

- C언어는 **싱글 소스**이다.
  - 소스파일을 각 기계(OS)에 맞는 컴파일러로 컴파일만 하면 각 기계(OS)에 맞는 기계어 목적 파일이 만들어진다.
- 기계어, 어셈블리어, C언어 비교 
  
  |         |기계어      |어셈블리어   |C언어        |
  |---------|----------|----------|------------|
  |개발자의 코딩|0과 1의 나열|**일상 단어 사용**|**수학적 기호 사용**|
  |소스 파일|기종마다 하나씩|기종마다 하나씩|**기종이 몇개든 단 하나**|
  |목적 파일(기계어)|소스 그 자체|**어셈블러**로 소스를 번역해 생성|**컴파일러**로 소스를 번역해 생성|
  |목적 파일(기계어)| |어셈블러로 소스를 번역해 생성|기계어와 m:n대응하는 수학적 기호|

- C언어 특징
  - One Source : 하나의 C소스 파일만 작성
  - Multi Object : 기종마다 하나씩 기계어 목적 파일을 생성
  - Use Anywhere : 모든 컴퓨터에서 실행 가능

- 하지만 OS나름의 특성이 있었기 때문에 컴파일 전, OS에 맞게 **소스를 변경하는 작업(Fix Source)** 이 필요했다.
  - ex) 어떤 OS는 int를 2바이트로, 어떤 OS는 int를 4바이트로 인식함.

- 결론 : 어셈블리어보다 이식성이 좋다. 기계어와 1:1매칭이 아닌 m:n매칭이 가능해졌다.
  - 하지만 자바 대비 좋은것은 아니다.

#### C++언어 - 정말 인간적인 프로그래밍 방법론, 객체 지향