# 4.2 InnoDB 스토리지 엔진 아키텍처

<img width="550" alt="스크린샷 2024-04-18 오후 9 06 09" src="https://github.com/hoa0217/study-repo/assets/48192141/77f4d411-db3f-41e7-a73b-d76ea3ce0bcb">

- InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 유일하게 레코드 기반 잠금을 제공한다.
- 이를 통해 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

## 4.2.1 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 프라이머리 키를 기준으로 클러스터링되어 저장된다.
- 즉, 프라이머리 키 값의 순서대로 디스크에 저장된다.
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 **논리적인 주소**로 사용한다.
- 프라이머리 키가 **클러스터링 인덱스**이기 때문에, 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.
- 결과적으로 쿼리 실행 계획에서 다른 보조 인덱스에 비해 비중이 높게 설정된다. (실행 계획에서 선택될 확률이 높다) ➡️ 8.8장에서 자세히 다룸

MyISAM 스토리지 엔진은 클러스터링 키를 지원하지않는다.
- MyISAM 테이블에서 프러이머리 키와 세컨더리 인덱스는 구조적으로 차이가 없다.
- 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스일 뿐이다.
- MyISAM 테이블의 프라이머리 키를 포함하는 모든 인덱스는 물리적인 주소값(ROWID)를 갖는다. ➡️ 4.3.3에서 자세히 다룸

## 4.2.2 외래 키 지원
외래 키는 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM, MEMORY 테이블에서는 사용할 수 없다.
- 외래 키는 서버 운영의 불편함으로 생성하지 않는 경우도 있지만 개발 환경에서는 좋은 가이드 역할을 한다.
- InnoDB에서 외래키는 부모와 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고
- 변경 시 반드시 부모나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하다.
- 그로 인해 데드락이 발생할 때가 많으므로 개발 시 외래키 존재에 주의하자.

외래키가 복잡하게 얽힌경우 수동 데이터 생성/스키마 변경 등의 작업이 실패할 수 있다.
- 긴급하게 뭔가 조치를 해야하는데 문제가 발생한 경우 `foreign_key_checks` 시스템 변수를 OFF로 설정하면 외래 키 관계에 대한 체크작업을 일시적으로 멈출 수 있다.
- 멈추면 레코드 적재나 삭제 등의 작업도 부가적인 체크가 필요없기 때문에 빠르게 처리할 수 있다.

```sql
mysql> SET foreign_key_checks=OFF;
// 작업실행
mysql> SET foreign_key_checks=ON;
```
> 이는 GLOBAL, SESSION 모두 설정가능한 변수이다. 이런 작업을 수행할 땐 현재 세션에만 적용해야하므로 SESSION키워드를 명시하던지 아니면 아무것도 명시하지 않아야한다.
> 작업이 완료되면 반드시 현재 세션을 종료하거나, 외래키 체크를 활성화하자.

하지만 일시적으로 해제했다고 해서 부모-자식 관계가 깨진 상태로 유지해도되는 건 아니다.
- 만약 외래키 체크를 중지한 상태에서 외래키 관계를 가진 부모 레코드를 삭제했다면, 자식 레코드도 삭제해야한다.
- 그리고 일관성을 맞춰준 후 다시 외래키 체크 기능을 활성화해야한다.
> 만약 외래키 체크가 중지되었다면 `ON DELETE CASCADE`, `ON UPDATE CASCADE` 옵션은 무시된다.
> 이는 자동으로 자식 테이블에 매치되는 row에도 똑같이 DELETE, UPDATE를 반영하는 것을 의미한다.

### 4.2.3 MVCC(Multi Version Concurrency Control)
레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 **잠금을 사용하지 않는 일관된 읽기**를 제공하는 데 있다.
- InnoDB는 **Undo log**를 이용해 이 기능을 구현한다.
- 여기서 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미이다.

#### Isolation level에 따른 데이터 조회 예시

1. 테이블을 생성한다.
```sql
mysql> CREATE TABLE member (
    m_id INT NOT NULL,
    m_name VARCHAR(20) NOT NULL,
    m_area VARCHAR(100) NOT NULL,
    PRIMARY KEY (m_id),
    INDEX ix_area (m_area)
    );
```

2. 레코드 한건을 INSERT한다.
```sql
mysql> INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
mysql> COMMIT;
```

<img width="500" alt="스크린샷 2024-04-18 오후 9 48 48" src="https://github.com/hoa0217/study-repo/assets/48192141/6542d753-cfb7-4136-bf81-29b68789ee20">

3. 해당 레코드를 업데이트 한다.
```sql
mysql> UPDATE member SET m_area = '경기' where m_id = 12;
```

<img width="500" alt="스크린샷 2024-04-18 오후 9 50 30" src="https://github.com/hoa0217/study-repo/assets/48192141/5badc2e5-00fb-41a0-a578-00e689e5dfbd">

update 쿼리가 실행되면 커밋 실행 여부와 관계 없이 **InnoDB 버퍼풀**은 새로운 값으로 업데이트 된다.

그리고 **데이터 파일**(디스크)는 체크포인트나 InnoDB의 Write 스레드에 의해 업데이트돼있을 수 도 있고 아닐 수 도 있다.
- InnoDB가 ACID를 보장하기 때문에 일반적으로 InnoDB의 버퍼풀과 데이터파일은 동일한 상태라고 가정해도 무방하다.

아직 COMMIT이나 ROLLBACK을 하지 않은 상태에서 다른 사용자가 조회하면 어디 데이터를 조회할까?
```sql
SELECT * FROM member where m_id = 12;
```
- 이는 시스템변수(transaction_isolation)에 설정된 Isolation level(격리수준)에 따라 다르다.
- `READ_UNCOMMITTED`: 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.
- `READ_COMMITTED` or 그 이상의 격리: 아직 커밋이 되지 않았기 때문에 버퍼 풀이나 데이터 파일 대신 변경되기 이전의 내용을 보관하고 있는 **언두 영역의 데이터를 반환한다.**
  - 그 이상의 격리: `REPEATABLE_READ`, `SERIALIZABLE`
 
#### 그래서 MVCC란
이러한 과정을 DBMS에서는 MVCC라고 표현한다. 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 상황에 따라 달라지는 구조다.
- 여기서는 한개의 데이터만가지고 설명했지만, 예전 버전의 데이터는 무한히 많아질 수 있다.
- 만약 트랜잭션이 길어지면 언두에서 관리하는 예전 데이터는 삭제되지 못하고 오래 관리돼야한다.
- 자연히 언두 영역이 시스템 테이블스페이스의 공간을 많이 차지하게된다.

#### COMMIT & ROLLBACK
위 상태에서 커밋을 실행하면, InnoDB는 더이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버린다.

하지만 롤백을 실행하면 InnoDB는 언두 영역에 있는 데이터를 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제한다.

> 커밋을 한다고해서 언두 영역의 데이터가 바로 삭제되는 것은 아니며, 언두 영역을 필요로 하는 트랜잭션이 없을 때 삭제된다.



