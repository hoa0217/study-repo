## 1. 사람을 사랑한 기술
### 신기술은 이전 기술의 어깨를 딛고

- 스프링을 비롯한 모든 신기술은 이전 기술의 철학과 기법을 정제하고 더해 나타나는 것이다.
- 스프링 이전에는 어떤 기술을 이해하고 있어야할까?
  - SOA
  - CBD
  - OOP
  - 절차적/구조적 프로그래밍
  - **기계어와 어셈블리** (모범답안)
> 이전 기술을 마스터 할 필요는 없다. 빠르게 돌아보자.

<hr/>

### 기계어에서 객체 지향 프로그래밍 언어로

#### 기계어 - 0과 1의 행진 / 너무나 비인간적인 언어

- 컴퓨터는 0과 1밖에 이해하지 못하지만 대단히 **빠르고 성실하며 정확하다.**
- 인류 최초의 프로그래머들은 0과 1로 해석할 수 있는 백열전구를 이용해 프로그램을 작성했다.
- 기계어 : 기계가 이해하는 유일한 언어로, 2진 숫자인 0과 1로만 표현된다.
  - 기계어 코드는 CPU에 따라 다르다. 
  - 즉, 기종간 호환이 불가능하다.
    
```
01010101 00000001 00001001
```

> 1+3을 수행하는 애드삭(EDSAC) 기계어 프로그래밍 코드

```
11011100 00011000 10011000
```

> 1+3을 수행하는 유니박(UNIVAC) 기계어 프로그래밍 코드

#### 어셈블리어 - 0과 1의 행진을 벗어나 인간 지향으로 / 기계어 니모닉

- 기계어는 컴퓨터가 이해하는 유일한 언어지만 인간이 눈높이에는 수준이 너무 낮다.
- 어느날 한 천재가 아래와 같은 생각으로 **니모닉(Mnemonic)** 과 **기계어** 1대1 매칭 **코드표**를 만들었다.
  > 기계어 명령어를 일상용어로 표현하고 이걸 기계가 알 수 있는 기계어로 번역하게 하면 어떨까?
  - 이 코드표가 **어셈블리**이다.
- 하지만 CPU별로 기계어가 다르기 때문에 **어셈블리어(Assembly Language)** 도 달랐다.
  - 어셈블러(Assembler) : 어셈블리어를 기계어로 번역해주는러 SW 
  - 애드삭 : 더하기를 의미하는 `01010101` ➡️ 니모닉으로 **ADD**
  - 유니박 : 더하기를 의미하는 `11011100` ➡️ 니모닉으로 **PLUS**
- 결론 : **어셈블리어**를 통해 기계어를 벗어나 **인간의 언어**를 모방해 프로그램 작성이 가능해졌다.
  - 하지만 애드삭 어셈블리어로 유니박을 실행할 수는 없다.

#### C언어 - 강력한 이식성 / One Source Multi Object Use Anywhere

- C언어는 **싱글 소스**이다.
  - 소스파일을 각 기계(OS)에 맞는 컴파일러로 컴파일만 하면 각 기계(OS)에 맞는 기계어 목적 파일이 만들어진다.
- 기계어, 어셈블리어, C언어 비교 
  
  |         |기계어      |어셈블리어   |C언어        |
  |---------|----------|----------|------------|
  |개발자의 코딩|0과 1의 나열|**일상 단어 사용**|**수학적 기호 사용**|
  |소스 파일|기종마다 하나씩|기종마다 하나씩|**기종이 몇개든 단 하나**|
  |목적 파일(기계어)|소스 그 자체|**어셈블러**로 소스를 번역해 생성|**컴파일러**로 소스를 번역해 생성|
  |기계어 비교| |어셈블러로 소스를 번역해 생성|기계어와 m:n대응하는 수학적 기호|

- C언어 특징
  - **One Source** : 하나의 C소스 파일만 작성
  - **Multi Object** : 기종마다 하나씩 기계어 목적 파일을 생성
  - **Use Anywhere** : 모든 컴퓨터에서 실행 가능

- 하지만 OS나름의 특성이 있었기 때문에 컴파일 전, OS에 맞게 **소스를 변경하는 작업(Fix Source)** 이 필요했다.
  - ex) 어떤 OS는 int를 2바이트로, 어떤 OS는 int를 4바이트로 인식함.

- 결론 : 어셈블리어보다 이식성이 좋다. 기계어와 1:1매칭이 아닌 m:n매칭이 가능해졌다.
  - 하지만 자바 대비 좋은것은 아니다.

#### C++언어 - 정말 인간적인 프로그래밍 방법론, 객체 지향

- C++ : C언어에 **객체 지향 개념**을 도입한 언어
  - 객체 지향 : 더 쉬운 프로그래밍을 위해 제안한 프로그래밍 방법론

#### 자바 - 진정한 객체 지향 언어
- 객체지향의 중심에는 **클래스(class)** 가 있다.
  - 자바는 클래스를 떠나 존재할 수 있는 것이 아무것도 없다.
    - `main()`를 포함한 모든 메서드는 클래스 내부에 존재해야하며, `객체or클래스.메서드명()`으로 접근해야한다.
  - 하지만 C++은 **객체 없는 프로그래밍**도 가능하다. ➡️ 객체 지향 지원 언어
    - `main()`는 클래스와 별개로 존재할 수 있으며 `printf()`는 클래스나 객체와 관계없이 호출할 수 있다. 
- 자바 = **Write Once Use Anywhere**
  - 컴파일러를 기종별로 구비하지 않아도 되며, 자바 컴파일러는 무료다.
  
  <img src="img/jvm_jre_jdk.jpeg" width="80%"/>

- 어셈블리어, C, 자바 비교
  - 작성한 소스를 다른 기종의 컴퓨터에서 실행하려면?
  - C언어 : 각 기종용 컴파일러로 목적파일을 생성한다.
  - 자바 : 단 하나의 목적 파일만 가져가면된다.
    - 물론 다른 기종의 컴퓨터에 해당 기종용 **JRE** 설치 필수.

  |         |어셈블리어   |C언어        |자바        |
  |---------|----------|------------|------------|
  |개발자의 코딩|일상 단어 사용|수학적 기호 사용|수학적 기호 사용|
  |소스 파일|기종마다 하나씩|기종이 몇개든 단 하나|기종이 몇개든 단 하나|
  |목적 파일|어셈블러로 기계어 생성|컴파일러로 해당 운영체제용 기계어 생성|**기종이 몇 개든 단 하나**의 JVM용 기계어 생성|
  |기계어 비교|기계어랑 1:1 대응하는 니모닉|기계어와 m:n대응하는 수학적 기호|기계어와 m:n대응하는 수학적 기호|
  |비고|기종별 어셈블러 필요|기종별 컴파일러 필요|단 하나의 컴파일러만 필요, **기종별 JRE 세팅 필요(한번만 설치해주면 됨)**|





  
