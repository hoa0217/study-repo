### 14.1 HTTP안전하게 만들기

웹은 안전한 방식의 HTTP를 필요로 하며, 아래와 같은 보안 기술이 필요로한다.

- 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기 하고 있음을 알 수 있어야 한다.
- 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기 하고 있음을 알 수 있어야 한다.
- 무결성 - 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
- 암호화 - 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
- 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야한다.
- 편재성(Ubiquity) - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- 관리상 확장성 - 누그든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 한다.
- 사회적 생존성 - 사회의 문화적, 정치적 요구를 만족시켜야 한다.

#### 1.4.1 HTTPS
- HTTPS는 HTTP를 안전하게 만드는 방식 중 가장 인기 있는 것이다.
    - 넷스케이프 커뮤니케이션 주식회사에서 개척하여, 주류 브라우저와 서버에서 지원한다.
    - URL이 `https://`로 시작한다.
- HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전 암호화 된다.
- HTTPS는 HTTP 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작한다.
    - 이 보안 계층은 안전 소켓 계층(Secure Sockets Layer, SSL)혹은 그를 계승한 전송 계층 보안(Transport Layer Security, TLS)로 구현된다.
- SSL과 TLS는 매우 비슷하기 때문에 이 책에서는 양쪽 모두 **SSL**이라는 단어를 사용한다.
- HTTPS

  |프로토콜|계층|
  |------|---|
  |HTTP|응용 계층|
  |SSL 혹은 TLS|보안 계층|
  |TCP|전송 계층|
  |IP|네트워크 계층|
  |네트워크 인터페이스|데이터 링크 계층|

> 인코딩/디코딩은 대부분 SSL 라이브러리 안에서 일어나기 때문에, HTTP를 사용하기 위해 클라이언트/서버가 프로토콜 처리 로직을 변경할 필요는 없다.   
> 대부분 TCP 입력/출력 호출을 SSL 호출로 대체하고, 보안 설정 및 관리를 위한 몇가지 호출을 추가하기만 하면된다.

### 14.2 디지털 암호학

- 암호 : 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키 : 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계 : 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계 : 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법 : 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명 : 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서 : 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

#### 14.2.1 비밀 코드의 기술과 과학
- 압호법(crtptography) : 메시지 인코딩과 디코딩에 대한 과학이자 기술이다.
- 암호법은 단순 메시지를 암호화하는 것 뿐 아니라, 변조를 방지하기 위해 사용할 수 있다.
- 암호법은 누군가를 어떤 메시지나 트랜잭션의 저자임을 증명하는데도 사용될 수 있다.

#### 14.2.2 암호(cipher)
- 암호법은 암호란 비밀 코드에 기반한다.
- **암호** : 메시지를 인코딩하는 어떤 특정한 방법과, 그 메시지를 디코딩하는 방법
- 평문 : 인코딩 되기 전의 원본
- 암호문 : 암호가 적용되어 코딩된 메시지
- 평문 ➡ 인코더 ➡ 암호문 ➡ 디코더 ➡ 평문

    <img src="img/14-3.jpeg" width="600"/>

- Rotate-by-3 암호 : 글자의 알파벳 순서상 세 번 뒤의 글자로 교체

    <img src="img/14-4.jpeg" width="600"/>

    - 인코딩 : 3글자 만큼 회전
    - 디코딩 : -3글자 만큼 회전
    
#### 14.2.3 암호 기계
- 암호는 상대적으로 간단한 알고리즘으로 시작했다.
    - 간단한 암호로 인해 사람들은 암호화 작업을 수기로 수행할 수 있었고 암호를 깨뜨리는 것도 가능했다.
- 기술이 진보하면서 복잡한 암호로 메시지를 빠르고 정확하게 인코딩, 디코딩하는 기계를 만들었다.
    - 단순 회전대신 글자를 대체하고 순서를 바꾸고 메시지를 토막냈다.

#### 14.2.4 키가 있는 암호
- 키 : 암호의 동작방식을 변경할 수 있는 숫자
- 디코딩 과정을 바르게 동작시키려면 올바른 키를 암호 기계에 임력해야한다.
- 암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어준다.
- 이 가상 암호 기계들은 서로 다른 키 값을 갖고 있기 때문에 제각각 다르게 동작한다.

> 오늘날 대부분의 암호 알고리즘은 키를 사용한다.

#### 14.2.5 디지털 암호
- 디지털 계산의 도래로 디지털 암호가 발전했다.
    - 복잡한 인코딩, 디코딩 알고리즘이 가능해졌다.
    - 매우 큰 키를 지원하는 것이 가능해졌다.
        - 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 알고리즘을 만들어 낼 수 있다.
- 디지털 키는 물리적 금속 키나 다이얼 설정과 달리, 그냥 숫자에 불과하다.
    - 디지털 키 값은 인코딩/디코딩 알고리즘에 대한 입력값이다.
- 평문 메시지 P, 인코딩 함수 E, 인코딩 키 e가 주어지면 암호화문 C를 인코딩할 수 있다.
- 암호문 C를 디코더 함수 D와 디코딩 키 d를 사용해서 평문 P로 디코딩할 수 있다.
   
    <img src="img/14-6.jpeg" width="600"/>

> 인코딩 함수 E와 디코더 함수 D는 역의 관계다.

### 14.3 대칭키 암호법
- 대칭키 암호법은 인코딩/디코딩할 때 암호키가 같다.
- 따라서 발신자와 수신자 모두 통신을 위해 비밀키를 똑같이 공유해야한다.
- ex) DES, Triple-DES, RC2, RC4 등

#### 14.3.1 키 길이와 열거 공격(Enumeration Attack)
- 대부분 인코딩, 디코딩 알고리즘은 공개적이므로 **비밀 키**는 절대 누설되면 안된다.
- 열거 공격 : 무차별로 모든 키 값을 대입해보는 공격
    - 만약 가능한 키가 몇가지 없다면 열거 공격으로 암호를 깰 수 있다.
    - 하지만 가능한 키가 아주 많다면 우주 수명만큼 시간을 들여야한다.
- 가능한 키 값의 개수는 **몇비트**인지, 얼마나 많은 키가 **유효**한지에 달려있다.
    > 대칭키 암호에서는 보통 모든 키가 유효하다.
    - 8비트 : 256가지
    - 40비트 : 2^40(약 1조)
    - 128비트 : 2^128
- 암호에 기반한 보안에서 **키의 길이**는 굉장히 중요하다.
    - 미국정부는 긴 키를 사용하는 암호화 SW 수출을 통제한다.
    - 적대적 조직이 이를 통해 깰 수 없는 암호문을 만들 수 있기 때문에
- DES 암호를 깨뜨리는데 걸리는 시간
    
    <img src="img/14-1.jpeg" width="600"/>
  
    > Triple-DES 키와 비슷한 크기인 128비트키는 누가 얼마를 들이든 실질적으로 깨뜨릴 수 없다고 알려짐. 

#### 14.3.2 공유키 발급하기
- 대칭키 암호의 단점은 발송자/수신자가 **둘 다 공유키를 가져야 한다는 것**이다.
- 만약 N개의 노드가 있고, 각 노드가 상대 N-1과 통신을 해야한다면? 대략 N^2개의 비밀키가 필요하다.
  
  > N(N-1)/2

- 관리해야하는 입장에서 지옥이다.
