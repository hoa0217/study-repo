## 2부 빠른 암기법 습득
### FIRST : 좋은 테스트 조건
#### **Fast : 빠르다.**
- 지속적이고 종합적인 빠른 피드백을 위해 **테스트를 빠르게 유지**하라.
- 느린 것에 의존하는 코드를 최소화한다면 테스트코드 작성하기도 쉬워진다.
    - 의존성을 최소화 하는것 == 좋은 설계
#### **Isolated : 고립시킨다.**
- 좋은 단위 테스트는 **어떤 순서나 시간에 관계없이 실행**할 수 있어야한다.
    - 테스트 대상 코드가 DB에 의존성을 가진다면 외부 변화에 영향을 받고 실패할 가능성이 증가한다.
    - 테스트 코드가 다른 단위 테스트에 의존하게 된다면, 순서를 조작하여 테스트를 실행해야하며 테스트 실패시 이벤트의 긴사슬로 원인 파악에 긴 시간을 소모한다.
- 각 테스트가 작은 양의 동작에 집중하면 테스트 코드는 독립적으로 유지하기 쉬워진다.
    - 단일 책임 원칙으로 테스트가 하나 이상의 이유로 깨진다면 테스트를 분할하는 것을 고려하라.
#### **Repeatable : 좋은 테스트는 반복 가능해야 한다.**
- 반복 가능한 테스트는 실행할 때마다 **동일한 결과**를 만들어 내야한다.
- 직접 통제할 수 없는 외부 환경에 있는 항목들과 격리시켜야 한다.
- 만약 불가피하게 통제할 수 없는 요소와 상호작용해야한다면?
- 가짜 객체(목 객체)를 활용하자.
```java
@Test
public void questionAnswersDateAdded() {
    Instant now = new Date().toInstant();
    controller.setClock(Clock.fixed(now, ZoneId.of("America/Denver")));
    int id = controller.addBooleanQuestion("text");

    Question question = controller.find(id);

    assertThat(question.getCreateTimestamp(), equalTo(now));
}
```
- 이 예제의 경우 시간이 고정된 가짜 Clock객체를 controller에게 주입하여 test한다.
#### **Self-validating : 스스로 검증 가능하다.**
- 테스트 결과를 스스로 검증할 뿐 아니라 준비(설정)도 할 수 있어야한다.
- 또한 언제 어떻게 실행할지도 자동화 할 수 있다.
    - Infinitest : 백그라운드에서 대기하고 있다가 소스 코드를 저장할 때마다 자동으로 테스트를 실행함.
    - CI(지속적 통합) 도구: 코드를 소스 저장소에 통합할 때마다 빌드가 자동으로 수행되고 모든 테스트를 실행함.
        - ex) 젠킨스, TeamCity
#### **Timely : 적시에 사용한다.**
- 코드를 소스 저장소에 넣으면 그것을 되돌려 테스트를 작성하기 힘들다.
    - 계속 미루게 되면 결함이 늘어나게 됨.
- 따라서 적절한 순간 단위테스트를 작성하는 습관을 들여야한다.
- 단위테스트를 많이 할 수록 테스트 대상 코드가 줄어든다. 그렇다는건 ?
    1. 테스트 작성이 쉬워진다.
    2. 새로운 코드를 넣었을 때 테스트 효과가 즉시 나타난다.
> 옛날 코드에 대한 테스트는 시간 낭비가 될 수 있다. 큰 결함이 없고 당장 변경할 예정이 없다면 그 노력을 역동적인 부분에 사용하라.
---
### Right-BICEP : 무엇을 테스트 할 것인가?
#### **Right : 결과가 올바른가?**
- 테스트코드는 기대한 결과를 산출하는지 검증할 수 있어야한다.
- 이 코드가 정상적으로 동작한다면, 나는 어떻게 그것을 알 수 있을까?
    - 이 부분에 대한 답변이 바로 테스트다.
    - 만약 답할 수 없다면 실제 코드 작성을 중단하라.
  > 요구사항이 불완전하다면?   
  > 단위테스트는 현재까지 코드가 어떻게 동작하는지를 문서화하는 것이다. 따라서 요구사항에 대한 최선의 판단 후 나중에 명확해 졌을 때 개선하면된다.
#### **B : 경계 조건은 맞는가?**
- 우리가 마주치는 수많은 결함은 모서리 사례(coner-case)에 있다.
- 생각해야하는 경계 조건
    - 모호하고 일관성 없는 입력 값 ex) 특수문자가 포함된 파일 이름
    - 잘못된 양식의 데이터 ex) 최상위 도메인이 빠진 이메일 주소 fred@naver.
    - 수치적 오버플로우를 일으키는 계산
    - 비거나 빠진 값 ex) 0, "", null
    - 이상적인 기댓값을 벗어나는 값 ex) 150살
    - 중복을 허용하지 않는 목록에 중복 값이 들어가는 경우 ex) 교실 당번표
    - 정렬이 안된 정렬리스트 ex) 정렬알고리즘에 역순데이터 넣기
    - 시간 순서가 맞지 않는 경우 ex) http 응답 순서
#### **I : 역 관계를 검사할 수 있는가?**
- 논리적 역관계를 적용하여 행동을 검사할 수 있다.
    - 곱셈으로 나눗셈을 검증
    - 뺄셈으로 덧셈을 검증
- 예제
```java
@Test
public void findsAnswersBasedOnPredicate() {
  profile.add(new Answer(new BooleanQuestion(1, "1"), Bool.FALSE));
  profile.add(new Answer(new PercentileQuestion(2, "2", new String[]{}), 0));
  profile.add(new Answer(new PercentileQuestion(3, "3", new String[]{}), 0));

  List<Answer> answers =
     profile.find(a->a.getQuestion().getClass() == PercentileQuestion.class);

  assertThat(ids(answers), equalTo(new int[] { 2, 3 }));

  List<Answer> answersComplement =
     profile.find(a->a.getQuestion().getClass() != PercentileQuestion.class); // 역관계

  List<Answer> allAnswers = new ArrayList<Answer>();
  allAnswers.addAll(answersComplement);
  allAnswers.addAll(answers);

  assertThat(ids(allAnswers), equalTo(new int[] { 1, 2, 3 }));
}
```
- Predicate와 반대 Predicate를 통해 찾은 Answer를 더하여 전체가 나오는지를 검사하는 test이다.
#### **C : 다른 수단을 활용하여 교차 검사할 수 있는가?**
- 다른 해법(성능이 조금 떨어질지라도 참값을 보장하는)을 이용하여 교차검증을 수행한다.
- ex) 뉴턴의 제곱근과 성능이 떨어지는 Java라이브러리의 제곱근 비교
#### **E : 오류조건을 강제로 일어나게 할 수 있는가?**
- 실전에서는 다양한 오류가 나올 수 있으며 이를 대비하기 위해서는 오류들을 강제로 발생시켜야한다.
- 고려해야할 시나리오 목록
    - 메모리가 가득찰 때
    - 디스크 공간이 가득찰 때
    - 서버와 클라이언트간 시간이 다를 때
    - 네트워크 가용성 및 오류
    - 시스템 로드
    - 제한된 색상 팔레트
    - 매우 높거나 낮은 비디오 해상도
#### **P : 성능 조건은 기준에 부합하는가?**
- 많은 프로그래머가 성능 문제가 어디에 있으며 최적의 해법이 무엇인지 추측한다.
- 하지만 추측보단 단위테스트를 설계하여, 문제가 어디있고 예상한 변경 사항으로 어떤 차이가 생겼는지 파악해야한다.
- 몇가지 주의 사항
    - 충분한 횟수 만큼 실행해야함. (타이밍과 CPU 클록 주기 이슈 제거)
    - 반복하는 코드 부분을 JVM이 최적화 하지 못하는지 확인해야함.
    - 최적화 되지 않은 테스트는 일반 테스트코드보다 매우 느림.
        - 따라서 빠른 테스트와 느린 테스트를 분리해야함.
    - 동일한 머신이라도 시스템 로드와 같은 요소에 따라 실행시간이 달라질 수 있음.
> 이런 단위 성능 측정은 변경 사항을 만들 때 **기준점**으로 활용할 수 있다.   
> 최적화 하기 전 몇번 성능 테스트를 실행한 후 평균을 계산하고, 코드를 변경한 후 평균을 계산하여 개선량을 찾는다.  
---
### CORRECT : 경계 조건
- Contormance(준수) : 값이 기대한 양식을 준수하고 있는가?
- Ordering(순서) : 값의 집합이 적절하게 정렬되었는가? (또는 정렬 x)
- Range(범위) : 이성적인 최솟값과 최댓값 안에 있는가?
- Reference(참조) : 코드 자체에서 통제할 수 없는 어떤 외부 참조를 포함하고 있는가?
- Existence(존재) : 값이 존재하는가? (null, 0, 집합 존재 등)
- Cardinality(기수) : 정확히 충분한 값들이 있는가?
  - 0, 1, n(비즈니스 요구사항에 따라 바뀜)
- Time(절대적 혹은 상대적 시간) : 모든 것이 순서대로 일어나는가? (정확한 시간에 혹은 정시에?)
  - 상대적 시간(시간순서), 절대적 시간(측정된 시간), 동시성 문제들