# Chapter10 이벤트
## 10.1 시스템 간 강결합 문제

만약 도메인 객체에서 환불 기능을 실행하려면, 환불 기능을 제공하는 도메인 서비스(RefundService)를 파라미터로 전달받고 실행해야한다.

<img width="500" alt="스크린샷 2024-06-01 오후 10 48 48" src="https://github.com/hoa0217/study-repo/assets/48192141/1061e3c9-f389-4b28-bad2-8ddf546be5fb">

또는 응용 서비스에서 환불 기능을 실행할 수도 있다.

<img width="500" alt="스크린샷 2024-06-01 오후 10 49 29" src="https://github.com/hoa0217/study-repo/assets/48192141/4d695d5a-0f9e-4e31-9a56-8fcd4f9fe8e8">


RefundService는 외부에 있는 결제 시스템이 제공하는 환불 서비스를 호출한다.

이 때 아래와 같은 2가지 문제가 발생할 수 있다.

1. 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야할까? (Commit or Rollback)
  - 롤백하는 것이 맞아보이지만, 주문은 취소 상태로 변경하고 환불만 나중에 시도하는 방식으로 처리할 수도 있다.
2. 외부 서비스 응답 시간이 길어지면 대기시간이 길어진다. 즉, 외부 서비스 성능에 직접적인 영향을 받게 된다.

그 외에도 도메인 객체에 서비스를 전달하면, 설계상 문제가 나타날 수 있다.
- 주문 로직과 결제 로직이 섞이는 문제가 있다.
- 만약 환불 기능이 바뀌면, Order도 영향을 받게 된다.
- Order의 코드를 결제 도메인 때문에 변경할지도 모르는 상황은 좋지 않다.

<img width="500" alt="스크린샷 2024-06-01 오후 10 55 22" src="https://github.com/hoa0217/study-repo/assets/48192141/8b48be9c-98e6-4e4d-9ce5-34a4a574b025">

또한 기능을 추가할 때도 문제가 발생한다.
- 만약 주문을 취소한 뒤 환불뿐 아니라 취소했다는 내용을 통지해야한다면 어떻게 될까?
- 환불 도메인 서비스와 동일하게 파라미터로 통지 서비스를 받도록 구현하면 로직이 섞이는 문제가 커지고 트랜잭션 처리 또한 복잡해진다.
- 영향을 주는 외부 서비스가 두 개로 증가한다.

<img width="500" alt="스크린샷 2024-06-01 오후 10 58 47" src="https://github.com/hoa0217/study-repo/assets/48192141/ffeb497e-b5b1-40c1-80bf-59c4d3e01e68">

#### 위 문제들이 발생하는 이유는?
주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트 간의 **강결합(High Coupling)** 때문이다.
- 주문이 결제와 강하게 결합되어 있어 주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트가 영향을 받게되는 것이다.

이런 강한 결합을 없애려면, **이벤트**를 사용해야한다.
- 비동기 이벤트를 사용하면 두 시스템간 결합을 크게 낮출 수 있다.

## 10.2 이벤트 개요
이벤트: 과거에 벌어진 어떤 것
- 주문을 취소했다면, `주문을 취소했음 이벤트`가 발생한 것

이벤트가 발생한다는 것은 상태가 변경됐다는 것을 의미한다.
- 주문 취소됨 이벤트가 발생한 이유는 주문을 취소했기 때문이다.

이벤트는 발생에서 끝나지 않는다. 
- 이벤트가 발생하면 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다.
- UI 컴포넌트를 보면 이벤트 발생에서 끝나지 않고, 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다.

<img width="500" alt="스크린샷 2024-06-01 오후 11 03 50" src="https://github.com/hoa0217/study-repo/assets/48192141/e9454049-2e13-42c7-8129-61b9fca0d6dd">

도메인 모델에서도 UI 컴포넌트와 유사하게 도메인 상태 변경을 이벤트로 표현할 수 있다.
- `~ 할 때`, `~가 발생하면`, `만약 ~하면`과 같은 요구사항은 도메인의 상태 변경과 관련된 경우가 많고 이런 요구사항을 이벤트를 이용해서 구현할 수 있다.
- 예를 들어 주문을 취소할 때 `이메일을 보낸다`라는 요구사항에 `주문을 취소할 때`는 주문이 취소 상태로 바뀌는 것을 의미함으로 `주문 취소됨 이벤트`를 활용해서 구현할 수 있다.

### 10.2.1 이벤트 관련 구성요소

도메인 모델에 이벤트를 도입하려면 이벤트, 이벤트 생성 주체, 이벤트 디스패처(퍼블리셔), 이벤트 핸들러(구독자)를 구현해야 한다.

<img width="500" alt="스크린샷 2024-06-01 오후 11 07 17" src="https://github.com/hoa0217/study-repo/assets/48192141/d2a8345a-c1d4-43d6-9bf9-78d3fedab5d5">

#### 도메인 모델에서 이벤트 관련 구성 요소

이벤트 생성 주체: 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체
- 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다.

이벤트 핸들러(구독자): 이벤트 생성 주체가 발생한 이벤트에 반응
- 생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.

이벤트 디스패처(퍼블리셔): 이벤트 생성 주체와 이벤트 핸들러를 연결해주는 것
- 이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달한다.
- 이벤트를 전달받은 디스패처는 해당 이벤트를 처리할 수 있는 핸들러에 이벤트를 전파한다.
- 이벤트 디스패처의 구현방식에 따라 이벤트 생성과 처리를 동기/비동기로 실행하게된다.

### 10.2.2 이벤트의 구성

이벤트는 이벤트에 대한 정보를 담는다.
- 이벤트 종류: 클래스 이름으로 이벤트 종류를 표현
- 이벤트 발생 시간
- 추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

#### 예시
배송지 변경 시 발생하는 이벤트를 위한 클래스를 아래와 같이 작성할 수 있다.
```java
public class ShippingInfoChangedEvent {
    
    private String orderNumber;
    private long timestamp;
    private ShippingInfo newShippingInfo;
    
    // 생성자, getter
}
```
- Changed라는 과거 시제를 사용했다. 이는 현재 기준 과거에 벌어진것을 표현한다.

이 이벤트 발생 주체는 Order애그리거트다. 
- 애그리거트의 배송지 변경 기능을 구현한 메서드는 배송지 변경 후 이벤트를 발생시킨다.
```java
public class Order {
    
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped();
        setShippingInfo(newShippingInfo);
        Event.raise(new ShippingInfoChangedEvent(number, newShippingInfo));
    }
}
```
> Event.raise: 디스패처를 통해 이벤트를 전파하는 기능을 제공한다.

ShippingInfoChangedEvent를 처리하는 핸들러는 디스패처로부터 이벤트를 전달받아 필요 작업을 수행한다.
```java
public class ShippingInfoChangedHandler {
    
    @EventListener(ShippingInfoChangedEvent.class)
    public void handle(ShippingInfoChangedEvent evt) {
        shippingInfoSynchronizer.sync(evt.getOrderNumber(), evt.getNewShippingInfo());
        }
    }
}
```

이벤트는 이벤트 핸들러가 작업을 수행하는데 필요한 데이터를 담아야한다.
- 데이터가 부족하면, 핸들러는 필요한 데이터를 일긱 위해 관련 API를 호출하거나 DB에서 데이터를 직접 읽어와야한다.
- 하지만 그렇다고 이벤트 자체와 관련 없는 데이터를 포함할 필요는 없다.

### 10.2.3 이벤트 용도
이벤트는 두가지 용도로 쓰인다.
1. 트리거(Trigger): 도메인 상태가 바뀔 때 다른 후처리가 필요하면, 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.
  - 주문을 취소하면 환불을 처리해야 하는데, 이때 환불 처리를 위한 트리거로 주문 취소 이벤트를 사용할 수 있다.
  - <img width="500" alt="스크린샷 2024-06-01 오후 11 32 23" src="https://github.com/hoa0217/study-repo/assets/48192141/43fca91c-4e04-4c52-b8bb-0734f78366fb">

2. 서로 다른 시스템 간의 데이터 동기화
  - 배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야한다.
  - 주문 도메인은 배송지 변경 이벤트를 발생시키고, 이벤트 핸들러는 외부 배송 서비스와 배송지 정보를 동기화할 수 있다.

### 10.2.4 이벤트 장점
이벤트를 사용하면 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.

<img width="500" alt="스크린샷 2024-06-01 오후 11 35 54" src="https://github.com/hoa0217/study-repo/assets/48192141/31e46bca-3913-42b0-bde2-27c9b6c487be">

- 환불 실행 로직은 주문 취소 이벤트를 받는 이벤트 핸들러로 이동한다.
- 이벤트를 사용하여 주문 도메인에서 결제 도메인으로의 의존을 제거했다.

이벤트 핸들러를 사용하면 기능 확장도 용이하다.

<img width="500" alt="스크린샷 2024-06-01 오후 11 38 48" src="https://github.com/hoa0217/study-repo/assets/48192141/87bedb65-1b28-4917-92cc-f700456f46e9">

- 구매 취소 시 환불과 함께 이메일로 취소 내용을 보내고 싶다면 이메일 발송을 처리하는 핸들러를 구현하면된다.
- 기능을 확장해도 구매 취소 로직은 수정할 필요가 없다.

## 10.3 이벤트, 핸들러, 디스패처 구현

실제 이벤트와 관련된 코드를 구현해보자.
- 이벤트 클래스: 이벤트를 표현한다.
- 디스패처: 스프링이 제공하는 ApplicationEventPublisher를 이용한다.
- Events: 이벤트를 발행한다. 이벤트 발행을 위해 ApplicationEventPublisher를 사용한다.
- 이벤트 핸들러: 이벤트를 수신해서 처리한다. 스프링이 제공하는 기능을 사용한다.

### 10.3.1 이벤트 클래스
이벤트를 위한 상위 타입은 존재하지 않는다. 원하는 클래스를 이벤트로 사용하면 된다.
- 이벤트는 과거에 벌어진 상태 변화나 사건을 의미하므로, 이벤트 클래스 이름을 결정할 때 과거 시제를 사용해야하는 점만 유의하면 된다.
- OrderCanceledEvent: 클래스 이름 뒤로 접미사로 Event를 사용해서 명시적으로 표현할 수 도 있다.
- OrderCanceled: 간결함을 위해 과거 시제만 사용할 수 있다.

이벤트 클래스는 이벤트를 처리하는데 필요한 최소한의 데이터를 포함해야한다.
- 예를 들어 주문 취소됨 이벤트는 적어도 주문번호를 포함해야 관련 핸들러에서 후속 처리를 할 수 있다.

모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면, 관련 상위 클래스를 만들고 각 이벤트 클래스가 상속받도록 할 수 있다.

<img width="500" alt="스크린샷 2024-06-01 오후 11 45 26" src="https://github.com/hoa0217/study-repo/assets/48192141/99f850b1-e431-4557-877b-29e56fe1d07f">

### 10.3.2 Events클래스와 ApplicationEventPublisher

스프링컨테이너는 ApplicationEventPublisher도 된다.Events 클래스는 ApplicationEventPublisher를 사용해서 이벤트를 발생시킨다.

<img width="500" alt="스크린샷 2024-06-02 오전 1 09 54" src="https://github.com/hoa0217/study-repo/assets/48192141/4dcc261d-617d-491b-8684-bd64392603a7">

- Events 클래스는 ApplicationEventPublisher가 제공하는 publishEvent 메서드를 이용하여 이벤트를 발생시킨다.

<img width="500" alt="스크린샷 2024-06-02 오전 1 16 46" src="https://github.com/hoa0217/study-repo/assets/48192141/15e7f908-53a8-4104-b596-7aa883429d08">

- 그리고 Events 클래스에 ApplicationEventPublisher를 전달하기 위해 스프링 설정을 위와 같이 작성한다.
- `eventsInitializer()`는 스프링 빈 객체를 초기화할 때 사용하는 인터페이스로, 이 기능을 사용해서 Events 클래스를 초기화한다.
- 참고로 ApplicationContext는 ApplicationEventPublisher를 상속하고 있다.

### 10.3.3 이벤트 발생과 이벤트 핸들러
위에서 구현한 Events의 `raise()`메서드를 이용하여 이벤트를 발생시킨다.

<img width="500" alt="스크린샷 2024-06-02 오전 1 20 19" src="https://github.com/hoa0217/study-repo/assets/48192141/16e0fae1-c297-4afe-956e-77fad7e10789">

이벤트를 처리할 핸들러는 스프링이 제공하는 @EventListener 애너테이션을 사용해 구현한다.

<img width="500" alt="스크린샷 2024-06-02 오전 1 21 06" src="https://github.com/hoa0217/study-repo/assets/48192141/8ba7acb0-ee86-4106-882e-901bbf235121">

ApplicationEventPublisher의 publishEvent메서드를 실행할 때 OrderCanceledEvent 타입 객체를 전달하면, OrderCanceledEvent.class 값을 갖는 @EventListener 애너테이션을 붙인 메서드를 찾아 실행한다.

### 10.3.4 흐름 정리

<img width="500" alt="스크린샷 2024-06-02 오전 1 23 22" src="https://github.com/hoa0217/study-repo/assets/48192141/6af248bd-1990-4246-bc1e-e5a18dead598">

1. 도메인 기능을 실행한다.
2. 도메인 기능은 Events.raise()를 이용해서 이벤트를 발생시킨다.
3. Events.raise()는 스프링이 제공하는 ApplicationEventPublisher를 이용해서 이벤트를 출판한다.
4. ApplicationEventPublisher는 @EventListener(이벤트타입.class)애너테이션이 붙은 메서드를 찾아 실행한다.

코드 흐름을 보면 응용 서비스와 동일한 트랜잭션 범위에서 이벤트 핸들러를 실행하고 있다.
- 즉, 도메인 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 실행된다.

## 10.4 동기 이벤트 처리 문제

이벤트를 사용하여 강결합 문제는 해소했지만, 외부 서비스에 영향을 받는 문제는 해결되지 못했다.

<img width="500" alt="스크린샷 2024-06-02 오전 1 27 39" src="https://github.com/hoa0217/study-repo/assets/48192141/5f392546-ba6e-45a1-ae39-45daa9f6fd9f">

해당 코드에서 refundService.refund()가 외부 환불 서비스와 연동한다고 가정해보자.
- 만약 외부 환불 기능이 갑자기 느려지면 cancel()메서드도 함께 느려진다.
- 이는 외부 서비스의 성능 저하가 바로 내 시스템의 성능 저하로 연결된다는 것을 의미한다.

성능 저하뿐 아니라 트랜잭션도 문제가 된다.
- refundService.refund()에서 익셉션이 발생하면 cancel()메서드도 트랜잭션을 롤백해야할까?
- 트랜잭션을 롤백하면 구매취소기능을 롤백하는 것이므로 구매 취소가 실패하는 것과 같다.

> 외부 환불 서비스 실행에 실패했다고 해서 반드시 트랜잭션을 롤백해야할까? 일단 구매 자체는 취소하고 환불만 재처리하거나 수동으로 처리할 수 있다.

외부 시스템과 연동을 동기로 처리할 때 발생하는 성능과 트랜잭션 범위 문제의 해결방법은
1. 이벤트를 비동기로 처리하거나
2. 이벤트와 트랜잭션을 연계하는 것이다.

## 10.5 비동기 이벤트 처리
